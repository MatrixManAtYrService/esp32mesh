#include <WiFi.h>
#include <esp_now.h>
#include <esp_wifi.h> // Include for esp_wifi_set_channel
#include <vector>     // For dynamic array for the cache
#include <algorithm>  // For std::remove_if, std::min_element, std::sort
#include <string.h>   // For strncpy and memset
#include <set>        // For storing unique MACs for display (used for logic to pick 4 unique)
#include <map>        // For storing unique MACs with their last seen timestamp for sorting
#include <DNSServer.h> // REQUIRED: Include for DNS server functionality
#include <esp_system.h> // For esp_read_mac
#include <esp_mac.h>    // Corrected: Added .h for esp_mac
#include <freertos/FreeRTOS.h> // Explicitly include FreeRTOS for queue types
#include <freertos/queue.h>    // Explicitly include queue definitions

#define USE_DISPLAY true

#if USE_DISPLAY
#include <TFT_eSPI.h>
TFT_eSPI tft = TFT_eSPI();
bool displayActive = false;

// Define the T_IRQ pin explicitly here for direct digitalRead debugging
#define TFT_TOUCH_IRQ_PIN 36 // Example: Change to 39 if your board uses GPIO39 for T_IRQ
#endif

// Maximum content length for the message, allowing for null terminator after decryption.
// The total message size is 250 bytes. With the addition of a 2-byte checksum,
// the content length is reduced from 238 to 236 bytes.
// Total message size: 4 (ID) + 6 (MAC) + 1 (TTL) + 1 (Type) + 2 (Checksum) + 236 (content array) = 250 bytes.
#define MAX_MESSAGE_CONTENT_LEN 236 // Max actual content length (reduced for checksum)
#define MAX_TTL_HOPS 40 // Maximum Time-To-Live (hops) for a message

// Message types for display prioritization
#define MSG_TYPE_ORGANIZER 0
#define MSG_TYPE_PUBLIC 1
#define MSG_TYPE_AUTO_INIT 2
#define MSG_TYPE_COMMAND 3
#define MSG_TYPE_UNKNOWN 4 // Default for messages without explicit type
#define MSG_TYPE_DISCOVERY 5 // New message type for peer discovery
#define MSG_TYPE_PASSWORD_UPDATE 6 // New message type for password updates

// Placing esp_now_message_t definition early to ensure it's recognized by the compiler.
// This uses the typedef struct syntax as provided in your original working code.
typedef struct __attribute__((packed)) {
  uint32_t messageID;
  uint8_t originalSenderMac[6];
  uint8_t ttl;
  uint8_t messageType; // Field to identify message type (organizer, public, etc.)
  uint16_t checksum;   // New field for integrity check
  char content[MAX_MESSAGE_CONTENT_LEN]; // Fixed size content buffer
} esp_now_message_t;


// The plaintext password for organizer access. This will be hashed at runtime.
// NOTE: This initial value is used only once at setup to generate the initial hashedOrganizerPassword.
// The actual password for login will be stored and updated in hashedOrganizerPassword.
const char* WEB_PASSWORD = "password"; 
// Stores the hash of WEB_PASSWORD, calculated at setup, and updated on password reset.
String hashedOrganizerPassword; 

const int WIFI_CHANNEL = 1;

WiFiServer server(80);
IPAddress IP; // This will store the actual IP of the SoftAP (192.168.4.1)
String MAC_full_str; // Full MAC address of this ESP32 (e.g., "AA:BB:CC:DD:EE:FF")
String MAC_suffix_str; // Last 4 chars of our MAC (e.g., "EEFF")
String ssid; // Our unique SSID
uint8_t ourMacBytes[6];

String userMessageBuffer = "";  // To hold the user-entered message from POST
String webFeedbackMessage = ""; // To send messages back to the web client (e.g., success/error)

String organizerSessionToken = "";          // Stores the active organizer session token
unsigned long sessionTokenTimestamp = 0;    // Timestamp of when the token was created/last used
const unsigned long SESSION_TIMEOUT_MS = 900000; // Session timeout: 15 minutes
bool publicMessagingEnabled = false;
bool passwordChangeLocked = false; // New flag to lock password changes after mesh update

int loginAttempts = 0;
unsigned long lockoutTime = 0;
const int MAX_LOGIN_ATTEMPTS = 20;
const unsigned long LOCKOUT_DURATION_MS = 300000; // 5 minutes

// Challenge-response authentication variables
String currentChallengeNonce = "";
unsigned long challengeNonceTimestamp = 0;
const unsigned long CHALLENGE_TIMEOUT_MS = 120000; // Increased to 120 seconds (2 minutes) for nonce validity

const char* CMD_PREFIX = "CMD::";
const char* CMD_PUBLIC_ON = "CMD::PUBLIC_ON";
const char* CMD_PUBLIC_OFF = "CMD::PUBLIC_OFF";

unsigned long totalMessagesSent = 0;
unsigned long totalMessagesReceived = 0;
unsigned long totalUrgentMessages = 0;

unsigned long lastRebroadcast = 0; // Timestamp for last re-broadcast
// Variable to track last display refresh time
const unsigned long DISPLAY_REFRESH_INTERVAL_MS = 10000;
unsigned long lastDisplayRefresh = 0;
// Constant for local display log management interval (e.g., 5 seconds)
const unsigned long LOCAL_DISPLAY_LOG_MANAGE_INTERVAL_MS = 5000;
unsigned long lastLocalDisplayLogManage = 0;
// Constant for last seen peers management interval
const unsigned long LAST_SEEN_PEERS_MANAGE_INTERVAL_MS = 60000; // 60 seconds
unsigned long lastSeenPeersManage = 0;

// Discovery message interval
const unsigned long PEER_DISCOVERY_INTERVAL_MS = 15000; // Send discovery every 15 seconds
unsigned long lastDiscoveryBroadcast = 0;


int counter = 1; // Still used for the initial auto message

IPAddress apIP(192, 168, 4, 1);
IPAddress netMsk(255, 255, 255, 0);

DNSServer dnsServer;

// Define a Pre-Shared Key (PSK) for symmetric encryption
// This key must be identical on all participating nodes.
// For simplicity and to meet "fully embedded", it's hardcoded.
// In a real-world scenario, this would be provisioned securely.
const uint8_t PRE_SHARED_KEY[] = {
  0x1A, 0x2B, 0x3C, 0x4D, 0x5E, 0x6F, 0x70, 0x81,
  0x92, 0xA3, 0xB4, 0xC5, 0xD6, 0xE7, 0xF8, 0x09
};
const size_t PRE_SHARED_KEY_LEN = sizeof(PRE_SHARED_KEY);

// Simple PRNG state for the stream cipher
uint32_t prng_state;

// Function to seed the PRNG
void seedPrng(const uint8_t* key, size_t keyLen) {
    prng_state = 0;
    for (size_t i = 0; i < keyLen; ++i) {
        prng_state = (prng_state << 8) | key[i]; // Combine key bytes into seed
    }
    if (prng_state == 0) prng_state = 1; // Avoid zero seed
}

// Function to get next PRNG byte
uint8_t getPrngByte() {
    // Simple Linear Congruential Generator (LCG) parameters
    // These are NOT cryptographically secure, but provide a different stream.
    prng_state = (1103515245 * prng_state + 12345); 
    return (uint8_t)(prng_state >> 24); // Take higher bits for better distribution
}

// Stream cipher encryption/decryption using PRNG
// This function performs XOR operation with a PRNG-generated keystream in-place.
void prngStreamCipher(uint8_t* data, size_t dataLen, const uint8_t* key, size_t keyLen) {
    seedPrng(key, keyLen); // Seed PRNG for each operation to ensure determinism
    for (size_t i = 0; i < dataLen; i++) {
        data[i] = data[i] ^ getPrngByte();
    }
}

// Function to calculate a simple checksum (sum of bytes)
uint16_t calculateChecksum(const char* data, size_t len) {
    uint16_t sum = 0;
    for (size_t i = 0; i < len; ++i) {
        sum += (uint8_t)data[i]; // Sum of byte values
    }
    return sum;
}


struct SeenMessage {
  uint32_t messageID;
  uint8_t originalSenderMac[6];
  unsigned long timestamp;
  esp_now_message_t messageData; // Store the full message data (encrypted) for re-broadcasting
};

std::vector<SeenMessage> seenMessages;
portMUX_TYPE seenMessagesMutex = portMUX_INITIALIZER_UNLOCKED;

// Increased cache duration and size for more robust message persistence across disconnections
const unsigned long DEDUP_CACHE_DURATION_MS = 1800000; // 30 minutes (was 10 minutes)
const size_t MAX_CACHE_SIZE = 100; // Increased from 50
const unsigned long AUTO_REBROADCAST_INTERVAL_MS = 30000; // 30 seconds

QueueHandle_t messageQueue;
#define QUEUE_SIZE 10

// Struct to hold messages for local display, including timestamp for sorting
struct LocalDisplayEntry {
    esp_now_message_t message; // This message will be stored in its decrypted form
    unsigned long timestamp; // Timestamp when this message was added to localDisplayLog
};
std::vector<LocalDisplayEntry> localDisplayLog;
portMUX_TYPE localDisplayLogMutex = portMUX_INITIALIZER_UNLOCKED; // Corrected initialization
const size_t MAX_LOCAL_DISPLAY_LOG_SIZE = 50; // Max number of messages to keep in local display log
const size_t NUM_ORGANIZER_MESSAGES_TO_RETAIN = 5; // Number of most recent organizer messages to always keep

// Map to store MACs of all peers from which messages have been received (for display and peer management)
std::map<String, unsigned long> lastSeenPeers;
portMUX_TYPE lastSeenPeersMutex = portMUX_INITIALIZER_UNLOCKED;
const unsigned long PEER_LAST_SEEN_DURATION_MS = 600000; // 10 minutes for peer cleanup

// New map for peers added to ESP-NOW for sending (dynamic list)
std::map<String, unsigned long> espNowAddedPeers;
portMUX_TYPE espNowAddedPeersMutex = portMUX_INITIALIZER_UNLOCKED;
const unsigned long ESP_NOW_PEER_TIMEOUT_MS = 300000; // 5 minutes for ESP-NOW peer cleanup


enum DisplayMode {
  MODE_CHAT_LOG,
  MODE_URGENT_ONLY,
  MODE_DEVICE_INFO,
  MODE_STATS_INFO
};
DisplayMode currentDisplayMode = MODE_CHAT_LOG;

unsigned long lastTouchTime = 0;
const unsigned long TOUCH_DEBOUNCE_MS = 500;

#if USE_DISPLAY
void displayChatLogMode(int numLines);
void displayUrgentOnlyMode(int numLines);
void displayDeviceInfoMode();
void displayStatsInfoMode();
#endif

// A simple non-cryptographic hash function (DJB2 variant)
String simpleHash(const String& input) {
    unsigned long hash = 5381; // Initial value
    for (int i = 0; i < input.length(); i++) {
        hash = ((hash << 5) + hash) + input.charAt(i); // hash * 33 + c
    }
    return String(hash, HEX); // Return as hex string
}


String formatMac(const uint8_t *mac) {
  char buf[18];
  snprintf(buf, sizeof(buf), "%02X:%02X:%02X:%02X:%02X:%02X",
           mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  return String(buf);
}

String getMacSuffix(const uint8_t *mac) {
  char buf[5];
  snprintf(buf, sizeof(buf), "%02X%02X", mac[4], mac[5]);
  return String(buf);
}

String formatMaskedMac(const uint8_t *mac) {
  char buf[20];
  snprintf(buf, sizeof(buf), "xxxx.xxxx.xxxx.%02X%02X",
           mac[4], mac[5]);
  return String(buf);
}

String escapeHtml(const String& html) {
  String escaped = html;
  escaped.replace("&", "&amp;");
  escaped.replace("<", "&lt;");
  escaped.replace(">", "&gt;");
  escaped.replace("\"", "&quot;");
  escaped.replace("'", "&#39;");
  return escaped;
}

bool isOrganizerSessionValid(const String& token) {
  if (token.length() == 0 || organizerSessionToken.length() == 0) {
    return false;
  }
  if (millis() - sessionTokenTimestamp > SESSION_TIMEOUT_MS) {
    organizerSessionToken = "";
    return false;
  }
  return token == organizerSessionToken;
}

bool isMessageSeen(uint32_t id, const uint8_t* mac) {
  portENTER_CRITICAL(&seenMessagesMutex);
  bool found = false;
  for (const auto& msg : seenMessages) {
    if (msg.messageID == id && memcmp(msg.originalSenderMac, mac, 6) == 0) {
      found = true;
      break;
    }
  }
  portEXIT_CRITICAL(&seenMessagesMutex);
  return found;
}

void addOrUpdateMessageToSeen(uint32_t id, const uint8_t* mac, const esp_now_message_t& msgData) {
  portENTER_CRITICAL(&seenMessagesMutex);
  unsigned long currentTime = millis();
  bool updated = false;
  for (auto& msg : seenMessages) {
    if (msg.messageID == id && memcmp(msg.originalSenderMac, mac, 6) == 0) {
      msg.timestamp = currentTime;
      // The messageData (including its TTL) should remain as it was when first added to the cache,
      // which will be MAX_TTL_HOPS. This ensures re-broadcasts use full TTL potential.
      updated = true;
      break;
    }
  }
  if (!updated) {
    // Remove messages older than DEDUP_CACHE_DURATION_MS first
    seenMessages.erase(std::remove_if(seenMessages.begin(), seenMessages.end(),
                                     [currentTime](const SeenMessage& msg) {
                                         return (currentTime - msg.timestamp) > DEDUP_CACHE_DURATION_MS;
                                     }),
                      seenMessages.end());

    // If cache is still full after removing expired messages, remove the oldest one
    if (seenMessages.size() >= MAX_CACHE_SIZE) {
      auto oldest = std::min_element(seenMessages.begin(), seenMessages.end(),
                                     [](const SeenMessage& a, const SeenMessage& b) {
                                         return a.timestamp < b.timestamp;
                                     });
      if (oldest != seenMessages.end()) {
        seenMessages.erase(oldest);
      }
    }
    // When a message is *first* added to the cache, ensure its stored TTL is MAX_TTL_HOPS.
    // This makes the cache a reliable source for re-broadcasting with full TTL potential.
    esp_now_message_t storedMessage = msgData; // Copy the incoming message data
    storedMessage.ttl = MAX_TTL_HOPS; // Override TTL to its maximum for storage in cache
    SeenMessage newMessage = {id, {0}, currentTime, storedMessage};
    memcpy(newMessage.originalSenderMac, mac, 6);
    seenMessages.push_back(newMessage);
  }
  portEXIT_CRITICAL(&seenMessagesMutex);
}

void onDataRecv(const esp_now_recv_info *recvInfo, const uint8_t *data, int len) {
  if (len != sizeof(esp_now_message_t)) {
    return;
  }
  esp_now_message_t incomingMessage;
  memset(&incomingMessage, 0, sizeof(esp_now_message_t));
  memcpy(&incomingMessage, data, sizeof(esp_now_message_t));
  
  // Decrypt the content after receiving
  prngStreamCipher((uint8_t*)incomingMessage.content, MAX_MESSAGE_CONTENT_LEN, PRE_SHARED_KEY, PRE_SHARED_KEY_LEN);
  incomingMessage.content[MAX_MESSAGE_CONTENT_LEN - 1] = '\0'; // Ensure null termination after decryption

  // Calculate checksum on the decrypted content
  uint16_t calculatedChecksum = calculateChecksum(incomingMessage.content, strlen(incomingMessage.content));

  // Check if the calculated checksum matches the received checksum
  if (calculatedChecksum != incomingMessage.checksum) {
      Serial.println("Checksum mismatch! Dropping message.");
      return; // Drop the message if checksum verification fails
  }

  // If message has no TTL left upon arrival, discard it.
  if (incomingMessage.ttl == 0) {
      return;
  }

  // Update lastSeenPeers with the MAC of the immediate sender (for display on web/TFT)
  portENTER_CRITICAL(&lastSeenPeersMutex);
  lastSeenPeers[formatMac(recvInfo->src_addr)] = millis();
  portEXIT_CRITICAL(&lastSeenPeersMutex);

  // Add/Update peer in espNowAddedPeers for sending (dynamic peer management)
  String senderMacStr = formatMac(recvInfo->src_addr);
  portENTER_CRITICAL(&espNowAddedPeersMutex);
  bool peerExistsInMap = espNowAddedPeers.count(senderMacStr) > 0;
  portEXIT_CRITICAL(&espNowAddedPeersMutex);

  esp_now_peer_info_t peer{};
  memcpy(peer.peer_addr, recvInfo->src_addr, 6);
  peer.channel = WIFI_CHANNEL;
  peer.encrypt = false; // Custom encryption

  esp_err_t addPeerResult = esp_now_add_peer(&peer);
  if (addPeerResult == ESP_OK || addPeerResult == ESP_ERR_ESPNOW_EXIST) {
    portENTER_CRITICAL(&espNowAddedPeersMutex);
    espNowAddedPeers[senderMacStr] = millis(); // Update timestamp
    portEXIT_CRITICAL(&espNowAddedPeersMutex);
  } else {
    Serial.printf("Failed to add peer %s: %d\n", senderMacStr.c_str(), addPeerResult);
  }

  // Handle MSG_TYPE_DISCOVERY differently: Do not display, cache, or re-broadcast
  if (incomingMessage.messageType == MSG_TYPE_DISCOVERY) {
      return; // Stop processing this message further (silently handled)
  }

  // Check if the message has been seen before by THIS node (for display deduplication).
  bool wasAlreadySeen = isMessageSeen(incomingMessage.messageID, incomingMessage.originalSenderMac);

  bool skipDisplayLog = false; // Flag to control display logging

  // Handle MSG_TYPE_PASSWORD_UPDATE
  if (incomingMessage.messageType == MSG_TYPE_PASSWORD_UPDATE) {
      if (!wasAlreadySeen) { // Only process if new to this node
          Serial.println("Received password update command via mesh.");
          // The content is the plaintext new password (decrypted by onDataRecv already)
          hashedOrganizerPassword = simpleHash(String(incomingMessage.content));
          passwordChangeLocked = true; // Lock password change on this board
          Serial.println("Organizer password updated via mesh. Local change locked.");
      }
      skipDisplayLog = true; // Always skip display for password updates
  }

  // Always update the seen message cache first. This ensures the message's timestamp
  // is refreshed and its "full TTL potential" version is stored if new.
  // To do this, we re-encrypt the incomingMessage before passing it to the cache.
  esp_now_message_t encryptedForCache = incomingMessage; // Create a copy
  prngStreamCipher((uint8_t*)encryptedForCache.content, MAX_MESSAGE_CONTENT_LEN, PRE_SHARED_KEY, PRE_SHARED_KEY_LEN); // Re-encrypt for cache
  addOrUpdateMessageToSeen(encryptedForCache.messageID, encryptedForCache.originalSenderMac, encryptedForCache);


  // ONLY queue the message for local processing/display if it's truly new to this node.
  // If `wasAlreadySeen` is true, it means this node has already processed it for display
  // or originated it. The re-broadcast logic is handled separately by the cache.
  if (!wasAlreadySeen) {
      totalMessagesReceived++;
      if (String(incomingMessage.content).indexOf("Urgent: ") != -1) {
          totalUrgentMessages++;
      }

      // Add to local display log (decrypted version) - ONLY if not a password update
      if (!skipDisplayLog) { // Check the flag here
          portENTER_CRITICAL(&localDisplayLogMutex);
          LocalDisplayEntry newEntry = {incomingMessage, millis()}; // Store message and its reception timestamp
          localDisplayLog.push_back(newEntry);
          portEXIT_CRITICAL(&localDisplayLogMutex);
      }

      // Queue the encrypted message for further re-broadcasting by the main loop
      // The message that goes into the queue for re-broadcasting must be encrypted.
      esp_now_message_t encryptedForQueue = incomingMessage;
      prngStreamCipher((uint8_t*)encryptedForQueue.content, MAX_MESSAGE_CONTENT_LEN, PRE_SHARED_KEY, PRE_SHARED_KEY_LEN);
      
      BaseType_t xHigherPriorityTaskWoken = pdFALSE;
      if (xQueueSendFromISR(messageQueue, &encryptedForQueue, &xHigherPriorityTaskWoken) != pdPASS) {
        // Message dropped
      }
      if (xHigherPriorityTaskWoken == pdTRUE) {
        portYIELD_FROM_ISR();
      }
  }
}

// sendToAllPeers now takes a message by reference so its TTL can be decremented directly
void sendToAllPeers(esp_now_message_t& message) { // Changed to pass by reference
  uint8_t currentMacBytes[6];
  memcpy(currentMacBytes, ourMacBytes, 6);

  if (message.ttl > 0) {
      message.ttl--; // Decrement TTL here, as this is the point of sending (one hop)
  } else {
      Serial.println("Attempted to re-broadcast message with TTL 0. Skipping.");
      return;
  }

  portENTER_CRITICAL(&espNowAddedPeersMutex);
  for (auto const& [macStr, timestamp] : espNowAddedPeers) {
    uint8_t peerMacBytes[6];
    unsigned int tempMac[6];
    sscanf(macStr.c_str(), "%02X:%02X:%02X:%02X:%02X:%02X",
           &tempMac[0], &tempMac[1], &tempMac[2], &tempMac[3], &tempMac[4], &tempMac[5]);
    for (int k = 0; k < 6; ++k) { peerMacBytes[k] = (uint8_t)tempMac[k]; }

    // Only send to peers that are NOT our own MAC and NOT the original sender of this message
    if (memcmp(peerMacBytes, currentMacBytes, 6) != 0 && memcmp(peerMacBytes, message.originalSenderMac, 6) != 0) {
      // The message content is already encrypted when it reaches here.
      esp_now_send(peerMacBytes, (uint8_t*)&message, sizeof(esp_now_message_t));
    }
  }
  portEXIT_CRITICAL(&espNowAddedPeersMutex);
}

// Helper function to create and send an ESP-NOW message (plaintext)
void createAndSendMessage(const char* plaintext_data, size_t plaintext_data_len, uint8_t type) {
  esp_now_message_t newMessage;
  memset(&newMessage, 0, sizeof(newMessage));
  newMessage.messageID = esp_random(); // Use esp_random for message ID
  memcpy(newMessage.originalSenderMac, ourMacBytes, 6);
  newMessage.ttl = MAX_TTL_HOPS; // Set initial TTL
  newMessage.messageType = type; // Set the message type

  // Copy plaintext data, ensuring null termination and max length
  size_t len_to_copy = std::min(plaintext_data_len, (size_t)MAX_MESSAGE_CONTENT_LEN - 1);
  strncpy(newMessage.content, plaintext_data, len_to_copy);
  newMessage.content[len_to_copy] = '\0'; // Ensure null termination for plaintext

  // Calculate checksum on plaintext content BEFORE encryption
  newMessage.checksum = calculateChecksum(newMessage.content, strlen(newMessage.content));

  // Encrypt the message content before sending
  prngStreamCipher((uint8_t*)newMessage.content, MAX_MESSAGE_CONTENT_LEN, PRE_SHARED_KEY, PRE_SHARED_KEY_LEN);

  // Send the message (sendToAllPeers will decrement TTL on 'newMessage' directly)
  sendToAllPeers(newMessage);
  totalMessagesSent++;

  // Special handling for discovery messages and password updates: DO NOT add to cache or local display log
  if (type == MSG_TYPE_DISCOVERY || type == MSG_TYPE_PASSWORD_UPDATE) { 
      return; // Do not proceed further for these message types
  }

  // Add to seen messages (newMessage now has its decremented TTL)
  // addOrUpdateMessageToSeen will store the message with MAX_TTL_HOPS
  // when it's first seen, regardless of its incoming TTL.
  addOrUpdateMessageToSeen(newMessage.messageID, newMessage.originalSenderMac, newMessage);

  // Add to local display log IMMEDIATELY for originating node
  portENTER_CRITICAL(&localDisplayLogMutex);
  // Decrypt for local display immediately after sending
  // Create a copy to decrypt for local display without altering the 'newMessage' that was sent.
  esp_now_message_t displayMessage = newMessage;
  // The checksum is already part of displayMessage, no need to recalculate for display.
  prngStreamCipher((uint8_t*)displayMessage.content, MAX_MESSAGE_CONTENT_LEN, PRE_SHARED_KEY, PRE_SHARED_KEY_LEN); // Decrypt for display
  displayMessage.content[MAX_MESSAGE_CONTENT_LEN - 1] = '\0'; // Ensure null termination
  LocalDisplayEntry newEntry = {displayMessage, millis()}; // Store message and its creation timestamp
  localDisplayLog.push_back(newEntry);
  portEXIT_CRITICAL(&localDisplayLogMutex);

  Serial.println("Sending (Plaintext): " + String(plaintext_data));
}

// Function to manage the local display log, ensuring organizer message retention and newest-first order
void manageLocalDisplayLog() {
    portENTER_CRITICAL(&localDisplayLogMutex);

    // 1. Sort the entire log by timestamp, newest first
    std::sort(localDisplayLog.begin(), localDisplayLog.end(), [](const LocalDisplayEntry& a, const LocalDisplayEntry& b) {
        return a.timestamp > b.timestamp; // Newest first
    });

    std::vector<LocalDisplayEntry> newLocalDisplayLog;
    std::set<std::pair<uint32_t, String>> addedMessageKeys; // To track unique messages by ID and MAC suffix

    // 2. Add the most recent organizer messages first
    int organizerCount = 0;
    for (const auto& entry : localDisplayLog) {
        if (entry.message.messageType == MSG_TYPE_ORGANIZER) {
            if (organizerCount < NUM_ORGANIZER_MESSAGES_TO_RETAIN) {
                newLocalDisplayLog.push_back(entry);
                addedMessageKeys.insert({entry.message.messageID, getMacSuffix(entry.message.originalSenderMac)});
                organizerCount++;
            }
        }
    }

    // 3. Add other messages (and any remaining organizer messages not yet added)
    //    until MAX_LOCAL_DISPLAY_LOG_SIZE is reached.
    for (const auto& entry : localDisplayLog) {
        if (newLocalDisplayLog.size() >= MAX_LOCAL_DISPLAY_LOG_SIZE) {
            break; // Max size reached
        }

        // Check if this message has already been added (either as a retained organizer or previously)
        if (addedMessageKeys.find({entry.message.messageID, getMacSuffix(entry.message.originalSenderMac)}) == addedMessageKeys.end()) {
            newLocalDisplayLog.push_back(entry);
            addedMessageKeys.insert({entry.message.messageID, getMacSuffix(entry.message.originalSenderMac)});
        }
    }

    localDisplayLog = newLocalDisplayLog;
    portEXIT_CRITICAL(&localDisplayLogMutex);
}


void setup() {
  Serial.begin(115200);
  randomSeed(analogRead(0));

  publicMessagingEnabled = false;
  passwordChangeLocked = false; // Initialize password change lock status

  messageQueue = xQueueCreate(QUEUE_SIZE, sizeof(esp_now_message_t));
  if (messageQueue == NULL) {
    Serial.println("Failed to create message queue!");
    while(true) { delay(100); }
  }

  // Calculate the hash of the WEB_PASSWORD at startup using the simple hash
  hashedOrganizerPassword = simpleHash(WEB_PASSWORD);

  WiFi.mode(WIFI_AP_STA);
  WiFi.setSleep(false);

  WiFi.softAP("placeholder", nullptr, WIFI_CHANNEL);
  delay(100);
  MAC_full_str = WiFi.softAPmacAddress();

  sscanf(MAC_full_str.c_str(), "%02X:%02X:%02X:%02X:%02X:%02X",
         (unsigned int*)&ourMacBytes[0], (unsigned int*)&ourMacBytes[1],
         (unsigned int*)&ourMacBytes[2], (unsigned int*)&ourMacBytes[3],
         (unsigned int*)&ourMacBytes[4], (unsigned int*)&ourMacBytes[5]);

  MAC_suffix_str = getMacSuffix(ourMacBytes);
  ssid = "ProtestInfo_" + MAC_suffix_str;

  WiFi.softAPConfig(apIP, apIP, netMsk);
  WiFi.softAP(ssid.c_str(), nullptr, WIFI_CHANNEL);
  IP = WiFi.softAPIP();
  server.begin();

  dnsServer.start(53, "*", apIP);
  Serial.println("DNS server started, redirecting all domains to: " + apIP.toString());

  esp_wifi_set_channel(WIFI_CHANNEL, WIFI_SECOND_CHAN_NONE);

#if USE_DISPLAY
  tft.begin();
  tft.setRotation(1);
  tft.fillScreen(TFT_BLACK);
  tft.setTextColor(TFT_YELLOW, TFT_BLACK);
  tft.setTextSize(1);
  tft.setCursor(0, 0);
  tft.println("Starting node...");
  displayActive = true;
  Serial.println("Display initialized");
  pinMode(TFT_TOUCH_IRQ_PIN, INPUT_PULLUP);
  Serial.printf("T_IRQ pin set to INPUT_PULLUP on GPIO%d\n", TFT_TOUCH_IRQ_PIN);
  displayChatLogMode(22);
#endif

  if (esp_now_init() != ESP_OK) {
    Serial.println("ESP-NOW init failed");
    while(true) { delay(100); }
  }

  // Add the broadcast MAC address as an initial peer for discovery messages
  uint8_t broadcastMac[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
  esp_now_peer_info_t peer{};
  memcpy(peer.peer_addr, broadcastMac, 6);
  peer.channel = WIFI_CHANNEL;
  peer.encrypt = false; // Explicitly set to false as we're using custom encryption
  esp_now_add_peer(&peer);
  
  portENTER_CRITICAL(&espNowAddedPeersMutex);
  espNowAddedPeers[formatMac(broadcastMac)] = millis(); // Add broadcast MAC to our dynamic peer list
  portEXIT_CRITICAL(&espNowAddedPeersMutex);

  esp_now_register_recv_cb(onDataRecv);

  // Initial auto-message
  char msgContentBuf[MAX_MESSAGE_CONTENT_LEN];
  snprintf(msgContentBuf, sizeof(msgContentBuf), "Node %s initializing", MAC_suffix_str.c_str());
  createAndSendMessage(msgContentBuf, strlen(msgContentBuf), MSG_TYPE_AUTO_INIT);

  // Initial discovery broadcast
  createAndSendMessage(MAC_full_str.c_str(), MAC_full_str.length(), MSG_TYPE_DISCOVERY);
  lastDiscoveryBroadcast = millis();

  lastRebroadcast = millis();
  lastLocalDisplayLogManage = millis(); // Initialize the timer for display log management
  lastSeenPeersManage = millis(); // Initialize the timer for last seen peers management
}

void loop() {
  dnsServer.processNextRequest();

  esp_now_message_t receivedMessage; // This message is already decrypted by onDataRecv
  bool messageProcessed = false;
  while (xQueueReceive(messageQueue, &receivedMessage, 0) == pdPASS) {
    receivedMessage.content[MAX_MESSAGE_CONTENT_LEN - 1] = '\0'; // Ensure null termination
    String incomingContent = String(receivedMessage.content);
    String originalSenderMacSuffix = getMacSuffix(receivedMessage.originalSenderMac);

    if (incomingContent.startsWith(CMD_PREFIX)) {
        if (incomingContent.equals(CMD_PUBLIC_ON)) {
            if (!publicMessagingEnabled) {
                publicMessagingEnabled = true;
                Serial.println("Received command: ENABLE public messaging.");
                webFeedbackMessage = "<p class='feedback' style='color:blue;'>Public messaging was ENABLED by an organizer.</p>";
            }
        } else if (incomingContent.equals(CMD_PUBLIC_OFF)) {
            if (publicMessagingEnabled) {
                publicMessagingEnabled = false;
                Serial.println("Received command: DISABLE public messaging.");
                webFeedbackMessage = "<p class='feedback' style='color:blue;'>Public messaging was DISABLED by an organizer.</p>";
            }
        }
    }

    Serial.println("Message received from queue: Node " + originalSenderMacSuffix + " - " + incomingContent);
    messageProcessed = true;

    // IMPORTANT: When re-broadcasting from the queue, we need to send the *encrypted* version.
    // The message in `receivedMessage` from the queue is currently decrypted.
    // We also need to respect its current TTL.
    if (receivedMessage.ttl > 0) {
        esp_now_message_t encryptedForRebroadcast = receivedMessage; // Create a copy
        prngStreamCipher((uint8_t*)encryptedForRebroadcast.content, MAX_MESSAGE_CONTENT_LEN, PRE_SHARED_KEY, PRE_SHARED_KEY_LEN); // Encrypt for re-broadcast
        sendToAllPeers(encryptedForRebroadcast);
    } else {
        Serial.println("Message reached TTL limit, not re-broadcasting.");
    }
  }

  if (millis() - lastRebroadcast >= AUTO_REBROADCAST_INTERVAL_MS) {
    lastRebroadcast = millis();
    portENTER_CRITICAL(&seenMessagesMutex);
    std::vector<esp_now_message_t> messagesToRebroadcast;
    for (const auto& seenMsg : seenMessages) {
      // When pulling from cache for auto-rebroadcast, the TTL in seenMsg.messageData
      // should already be MAX_TTL_HOPS due to the change in addOrUpdateMessageToSeen.
      // We still check > 0, though it should always be.
      if (seenMsg.messageData.ttl > 0) {
        messagesToRebroadcast.push_back(seenMsg.messageData); // These are already encrypted in cache
      }
    }
    portEXIT_CRITICAL(&seenMessagesMutex);

    for (auto& msg : messagesToRebroadcast) { // Use auto& to allow modification of msg
      // sendToAllPeers will decrement msg's TTL.
      // This 'msg' here is a copy from the cache, which had its TTL reset to MAX_TTL_HOPS.
      sendToAllPeers(msg);
    }
  }

  // Periodic discovery broadcast
  if (millis() - lastDiscoveryBroadcast >= PEER_DISCOVERY_INTERVAL_MS) {
      lastDiscoveryBroadcast = millis();
      // Send a discovery message. The content doesn't matter much, as it's silently handled.
      // Using our own MAC as content for identification if needed for debugging.
      createAndSendMessage(MAC_full_str.c_str(), MAC_full_str.length(), MSG_TYPE_DISCOVERY);
  }

  // Periodically manage the local display log
  if (millis() - lastLocalDisplayLogManage >= LOCAL_DISPLAY_LOG_MANAGE_INTERVAL_MS) {
      lastLocalDisplayLogManage = millis();
      manageLocalDisplayLog();
  }

  // Periodically manage the lastSeenPeers map and espNowAddedPeers
  if (millis() - lastSeenPeersManage >= LAST_SEEN_PEERS_MANAGE_INTERVAL_MS) {
      lastSeenPeersManage = millis();
      unsigned long currentTime = millis();

      // Cleanup lastSeenPeers (for display)
      portENTER_CRITICAL(&lastSeenPeersMutex);
      for (auto it = lastSeenPeers.begin(); it != lastSeenPeers.end(); ) {
          if ((currentTime - it->second) > PEER_LAST_SEEN_DURATION_MS) {
              it = lastSeenPeers.erase(it);
          } else {
              ++it;
          }
      }
      portEXIT_CRITICAL(&lastSeenPeersMutex);

      // Cleanup espNowAddedPeers (for sending)
      portENTER_CRITICAL(&espNowAddedPeersMutex);
      for (auto it = espNowAddedPeers.begin(); it != espNowAddedPeers.end(); ) {
          // Do not remove the broadcast MAC address
          if (it->first == "FF:FF:FF:FF:FF:FF") {
              ++it;
              continue;
          }
          if ((currentTime - it->second) > ESP_NOW_PEER_TIMEOUT_MS) {
              uint8_t peerMacBytes[6];
              unsigned int tempMac[6];
              sscanf(it->first.c_str(), "%02X:%02X:%02X:%02X:%02X:%02X",
                     &tempMac[0], &tempMac[1], &tempMac[2], &tempMac[3], &tempMac[4], &tempMac[5]);
              for (int k = 0; k < 6; ++k) { peerMacBytes[k] = (uint8_t)tempMac[k]; }
              esp_now_del_peer(peerMacBytes); // Remove from ESP-NOW internal peer list
              it = espNowAddedPeers.erase(it); // Remove from our map
          } else {
              ++it;
          }
      }
      portEXIT_CRITICAL(&espNowAddedPeersMutex);
  }


  WiFiClient client = server.available();
  if (client) {
    String currentLine = "";
    String postBody = "";
    bool isPost = false;
    unsigned long clientTimeout = millis();
    int contentLength = 0;
    String requestedPath = "/";

    while (client.connected() && (millis() - clientTimeout < 2000)) {
      if (client.available()) {
        clientTimeout = millis();
        char c = client.read();
        if (c == '\n') {
          if (currentLine.length() == 0) {
            String sessionTokenParam = "";
            bool isOrganizerRequest = false;

            // --- GET/POST and request path parsing ---
            if (isPost) {
                for (int i = 0; i < contentLength && client.available(); i++) {
                    postBody += (char)client.read();
                }
                Serial.println("Received POST Body: " + postBody);

                int tokenStart = postBody.indexOf("session_token=");
                if (tokenStart != -1) {
                    int tokenEnd = postBody.indexOf('&', tokenStart);
                    if (tokenEnd == -1) tokenEnd = postBody.length();
                    sessionTokenParam = postBody.substring(tokenStart + 14, tokenEnd);
                }
            } else { // It's a GET request
                int tokenStart = requestedPath.indexOf("session_token=");
                if (tokenStart != -1) {
                    sessionTokenParam = requestedPath.substring(tokenStart + 14);
                }
                // Handle /challenge endpoint for key exchange
                if (requestedPath == "/challenge") {
                    currentChallengeNonce = String(esp_random()); // Generate a random nonce
                    challengeNonceTimestamp = millis();
                    client.println(F("HTTP/1.1 200 OK"));
                    client.println(F("Content-type:text/plain"));
                    client.println(F("Connection: close"));
                    // Added Cache-Control headers for challenge endpoint
                    client.println(F("Cache-Control: no-cache, no-store, must-revalidate"));
                    client.println(F("Pragma: no-cache"));
                    client.println(F("Expires: 0"));
                    client.println();
                    client.print(currentChallengeNonce);
                    client.stop();
                    return;
                }

                // --- CAPTIVE PORTAL REDIRECT PATCH ---
                // --- BEGIN: Connectivity Check Response Patch ---
                if (!isPost) {
                  bool isConnectivityCheck = false;
                  String lowerPath = requestedPath;
                  lowerPath.toLowerCase();
                  if (
                      lowerPath == "/generate_204" ||
                      lowerPath == "/hotspot-detect.html" ||
                      lowerPath == "/ncsi.txt" ||
                      lowerPath == "/connecttest.txt" ||
                      lowerPath == "/captive-portal" ||
                      lowerPath == "/success.txt" ||
                      lowerPath == "/library/test/success.html" ||
                      lowerPath.startsWith("/redirect") ||
                      lowerPath.indexOf("connectivitycheck.gstatic.com") != -1 ||
                      lowerPath.indexOf("msftconnecttest.com") != -1 ||
                      lowerPath.indexOf("apple.com") != -1 ||
                      lowerPath.indexOf("hotspot-detect.html") != -1
                     ) {
                    isConnectivityCheck = true;
                  }

                  if (isConnectivityCheck) {
                    if (lowerPath == "/generate_204") {
                      client.println(F("HTTP/1.1 204 No Content"));
                      client.println(F("Connection: close"));
                      // Added Cache-Control headers for 204 responses
                      client.println(F("Cache-Control: no-cache, no-store, must-revalidate"));
                      client.println(F("Pragma: no-cache"));
                      client.println(F("Expires: 0"));
                      client.println();
                      client.stop();
                      return;
                    } else if (lowerPath == "/hotspot-detect.html" || lowerPath == "/ncsi.txt" || lowerPath == "/connecttest.txt" || lowerPath == "/success.txt") {
                      client.println(F("HTTP/1.1 200 OK"));
                      client.println(F("Content-Type: text/plain"));
                      client.println(F("Connection: close"));
                      // Added Cache-Control headers for text/plain responses
                      client.println(F("Cache-Control: no-cache, no-store, must-revalidate"));
                      client.println(F("Pragma: no-cache"));
                      client.println(F("Expires: 0"));
                      client.println();
                      client.println("Success");
                      client.stop();
                      return;
                    } else {
                      client.println(F("HTTP/1.1 200 OK"));
                      client.println(F("Content-Type: text/html"));
                      client.println(F("Connection: close"));
                      // Added Cache-Control headers for generic HTML success responses
                      client.println(F("Cache-Control: no-cache, no-store, must-revalidate"));
                      client.println(F("Pragma: no-cache"));
                      client.println(F("Expires: 0"));
                      client.println();
                      client.println(F("<html><head><title>Success</title></head><body>Success</body></html>"));
                      client.stop();
                      return;
                    }
                  }
                }
                // --- END: Connectivity Check Response Patch ---
                // Handle captive portal redirect for non-root GETs
                if (requestedPath != "/" && requestedPath.indexOf("?show_public") == -1 && tokenStart == -1) {
                    Serial.println("Intercepted non-root GET request for: " + requestedPath + ". Redirecting to captive portal.");
                    client.println(F("HTTP/1.1 302 Found"));
                    client.println(F("Location: http://192.168.4.1/"));
                    client.println(F("Connection: close"));
                    // Added Cache-Control headers for 302 redirects
                    client.println(F("Cache-Control: no-cache, no-store, must-revalidate"));
                    client.println(F("Pragma: no-cache"));
                    client.println(F("Expires: 0"));
                    client.println();
                    client.stop();
                    return;
                }
            }

            isOrganizerRequest = isOrganizerSessionValid(sessionTokenParam);

            if (isPost) {
              String messageParam = "", passwordParam = "", urgentParam = "", actionParam = "", newPasswordParam = "";
              // For challenge-response
              String challengeNonceReceived = "", passwordResponseHash = "";

              int messageStart = postBody.indexOf("message=");
              if (messageStart != -1) {
                int messageEnd = postBody.indexOf('&', messageStart);
                if (messageEnd == -1) messageEnd = postBody.length();
                messageParam = postBody.substring(messageStart + 8, messageEnd);
              }
              // This is the plaintext password from the client (will be cleared after hashing)
              int passwordStart = postBody.indexOf("password_plaintext_client=");
              if (passwordStart != -1) {
                int passwordEnd = postBody.indexOf('&', passwordStart);
                if (passwordEnd == -1) passwordEnd = postBody.length();
                passwordParam = postBody.substring(passwordStart + 26, passwordEnd);
              }
              if (postBody.indexOf("urgent=on") != -1) { urgentParam = "on"; }
              int actionStart = postBody.indexOf("action=");
              if (actionStart != -1) {
                int actionEnd = postBody.indexOf('&', actionStart);
                if (actionEnd == -1) actionEnd = postBody.length();
                actionParam = postBody.substring(actionStart + 7, actionEnd);
              }
              int newPasswordStart = postBody.indexOf("new_password=");
              if (newPasswordStart != -1) {
                  int newPasswordEnd = postBody.indexOf('&', newPasswordStart);
                  if (newPasswordEnd == -1) newPasswordEnd = postBody.length();
                  newPasswordParam = postBody.substring(newPasswordStart + 13, newPasswordEnd);
              }

              // Parse challenge-response parameters
              int nonceStart = postBody.indexOf("challenge_nonce=");
              if (nonceStart != -1) {
                  int nonceEnd = postBody.indexOf('&', nonceStart);
                  if (nonceEnd == -1) nonceEnd = postBody.length();
                  challengeNonceReceived = postBody.substring(nonceStart + 16, nonceEnd);
              }
              // This is the client-side hashed response
              int responseHashStart = postBody.indexOf("password_response_hash=");
              if (responseHashStart != -1) {
                  int responseHashEnd = postBody.indexOf('&', responseHashStart);
                  if (responseHashEnd == -1) responseHashEnd = postBody.length();
                  passwordResponseHash = postBody.substring(responseHashStart + 23, responseHashEnd);
              }


              messageParam.replace('+', ' ');
              String decodedMessage = "";
              for (int i = 0; i < messageParam.length(); i++) {
                if (messageParam.charAt(i) == '%' && (i + 2) < messageParam.length()) {
                  char decodedChar = (char)strtol((messageParam.substring(i + 1, i + 3)).c_str(), NULL, 16);
                  decodedMessage += decodedChar;
                  i += 2;
                } else {
                  decodedMessage += messageParam.charAt(i);
                }
              }

              newPasswordParam.replace('+', ' ');
              String decodedNewPassword = "";
              for (int i = 0; i < newPasswordParam.length(); i++) {
                if (newPasswordParam.charAt(i) == '%' && (i + 2) < newPasswordParam.length()) {
                  char decodedChar = (char)strtol((newPasswordParam.substring(i + 1, i + 3)).c_str(), NULL, 16);
                  decodedNewPassword += decodedChar;
                  i += 2;
                } else {
                  decodedNewPassword += newPasswordParam.charAt(i);
                }
              }


              if (actionParam == "enterOrganizer") {
                  if (lockoutTime > 0 && millis() < lockoutTime) {
                      webFeedbackMessage = "<p class='feedback' style='color:red;'>Too many failed attempts. Try again later.</p>";
                  } else {
                      if (lockoutTime > 0 && millis() >= lockoutTime) {
                          lockoutTime = 0;
                          loginAttempts = 0;
                      }

                      // Challenge-response verification (client-side hashed response)
                      // Validate nonce *before* processing the password hash
                      if (challengeNonceReceived != currentChallengeNonce ||
                          millis() - challengeNonceTimestamp > CHALLENGE_TIMEOUT_MS ||
                          currentChallengeNonce.length() == 0) {
                          webFeedbackMessage = "<p class='feedback' style='color:red;'>Login failed: Invalid or expired challenge.</p>";
                          // Clear nonce to force a new challenge for the next attempt
                          currentChallengeNonce = "";
                          challengeNonceTimestamp = 0;
                      } else {
                          // Use the simpleHash function with the *current* hashedOrganizerPassword
                          // The server computes: hash(stored_hashed_password + nonce)
                          String expectedResponse = simpleHash(hashedOrganizerPassword + challengeNonceReceived);

                          if (expectedResponse.equalsIgnoreCase(passwordResponseHash)) { // Compare with client-provided hash
                              loginAttempts = 0;
                              organizerSessionToken = String(esp_random()) + String(esp_random());
                              sessionTokenTimestamp = millis();
                              webFeedbackMessage = "<p class='feedback' style='color:green;'>Organizer Mode activated.</p>";
                              // Clear nonce on successful login
                              currentChallengeNonce = "";
                              challengeNonceTimestamp = 0;
                              client.println(F("HTTP/1.1 303 See Other"));
                              client.println("Location: /?session_token=" + organizerSessionToken);
                              client.println(F("Connection: close"));
                              // Added Cache-Control headers for 303 redirect after POST
                              client.println(F("Cache-Control: no-cache, no-store, must-revalidate"));
                              client.println(F("Pragma: no-cache"));
                              client.println(F("Expires: 0"));
                              client.println();
                              client.stop();
                              return;
                          } else {
                              loginAttempts++;
                              if (loginAttempts >= MAX_LOGIN_ATTEMPTS) {
                                  lockoutTime = millis() + LOCKOUT_DURATION_MS;
                                  loginAttempts = 0;
                                  webFeedbackMessage = "<p class='feedback' style='color:red;'>Login locked for 5 minutes due to too many failures.</p>";
                              } else {
                                  webFeedbackMessage = "<p class='feedback' style='color:red;'>Incorrect password. " + String(MAX_LOGIN_ATTEMPTS - loginAttempts) + " attempts remaining.</p>";
                              }
                              // Clear nonce on failed login to force a new challenge
                              currentChallengeNonce = "";
                              challengeNonceTimestamp = 0;
                          }
                      }
                  }
              } else if (actionParam == "exitOrganizer") {
                  if (isOrganizerRequest) {
                      organizerSessionToken = "";
                  }
                  webFeedbackMessage = "<p class='feedback' style='color:blue;'>Exited Organizer Mode.</p>";
              } else if (actionParam == "togglePublic") {
                  if (isOrganizerRequest) {
                      sessionTokenTimestamp = millis();
                      publicMessagingEnabled = !publicMessagingEnabled;
                      webFeedbackMessage = "<p class='feedback' style='color:blue;'>Public messaging has been " + String(publicMessagingEnabled ? "ENABLED" : "DISABLED") + ".</p>";
                      createAndSendMessage(publicMessagingEnabled ? CMD_PUBLIC_ON : CMD_PUBLIC_OFF, strlen(publicMessagingEnabled ? CMD_PUBLIC_ON : CMD_PUBLIC_OFF), MSG_TYPE_COMMAND);
                  } else {
                      webFeedbackMessage = "<p class='feedback' style='color:red;'>Error: Invalid or expired session.</p>";
                  }
              } else if (actionParam == "sendMessage") {
                  if (isOrganizerRequest) {
                      sessionTokenTimestamp = millis();
                      if (decodedMessage.length() == 0) {
                          webFeedbackMessage = "<p class='feedback' style='color:orange;'>Please enter a message.</p>";
                      } else {
                          if (urgentParam == "on") { decodedMessage = "Urgent: " + decodedMessage; }
                          if (decodedMessage.length() >= MAX_MESSAGE_CONTENT_LEN) {
                              decodedMessage = decodedMessage.substring(0, MAX_MESSAGE_CONTENT_LEN - 1);
                          }
                          createAndSendMessage(decodedMessage.c_str(), decodedMessage.length(), MSG_TYPE_ORGANIZER);
                          webFeedbackMessage = "<p class='feedback' style='color:green;'>Organizer message queued!</p>";
                      }
                  } else {
                      webFeedbackMessage = "<p class='feedback' style='color:red;'>Error: Invalid or expired session.</p>";
                  }
              } else if (actionParam == "sendPublicMessage") {
                  if (!publicMessagingEnabled) {
                      webFeedbackMessage = "<p class='feedback' style='color:red;'>Error: Public messaging is disabled.</p>";
                  } else if (decodedMessage.length() == 0) {
                      webFeedbackMessage = "<p class='feedback' style='color:orange;'>Please enter a message.</p>";
                  } else {
                      // Removed the redundant "Public: " prefixing here.
                      // The display logic will add it based on MSG_TYPE_PUBLIC.
                      if (decodedMessage.length() >= MAX_MESSAGE_CONTENT_LEN) {
                          decodedMessage = decodedMessage.substring(0, MAX_MESSAGE_CONTENT_LEN - 1);
                      }
                      createAndSendMessage(decodedMessage.c_str(), decodedMessage.length(), MSG_TYPE_PUBLIC);
                      webFeedbackMessage = "<p class='feedback' style='color:green;'>Public message queued!</p>";
                  }
              } else if (actionParam == "rebroadcastCache") {
                  if (isOrganizerRequest) {
                      sessionTokenTimestamp = millis();
                      int rebroadcastedCount = 0;
                      portENTER_CRITICAL(&seenMessagesMutex);
                      std::vector<esp_now_message_t> toRebroadcast;
                      for (const auto& seenMsg : seenMessages) {
                          // When pulling from cache for auto-rebroadcast, the TTL in seenMsg.messageData
                          // should already be MAX_TTL_HOPS due to the change in addOrUpdateMessageToSeen.
                          // We still check > 0, though it should always be.
                          if (seenMsg.messageData.ttl > 0) {
                            // Create a copy to send, decrementing its TTL for this hop
                            esp_now_message_t msgCopy = seenMsg.messageData;
                            sendToAllPeers(msgCopy); // msgCopy's TTL will be decremented here
                            rebroadcastedCount++;
                          }
                      }
                      portEXIT_CRITICAL(&seenMessagesMutex);
                      webFeedbackMessage = "<p class='feedback' style='color:green;'>Re-broadcasted " + String(rebroadcastedCount) + " messages!</p>";
                  } else {
                      webFeedbackMessage = "<p class='feedback' style='color:red;'>Error: Invalid or expired session.</p>";
                  }
              } else if (actionParam == "setOrganizerPassword") {
                  if (isOrganizerRequest) {
                      sessionTokenTimestamp = millis();
                      if (decodedNewPassword.length() == 0) {
                          webFeedbackMessage = "<p class='feedback' style='color:orange;'>New password cannot be empty.</p>";
                      } else {
                          // Check if password change is locked
                          if (passwordChangeLocked) {
                              webFeedbackMessage = "<p class='feedback' style='color:red;'>Password change is locked. You must reflash the board to change it again.</p>";
                          } else {
                              // Update local hashed password
                              hashedOrganizerPassword = simpleHash(decodedNewPassword);
                              webFeedbackMessage = "<p class='feedback' style='color:green;'>Organizer password updated successfully!</p>";
                              loginAttempts = 0; // Reset login attempts on successful password change
                              lockoutTime = 0;

                              // Broadcast the new password (plaintext) to the mesh
                              // It will be hashed and encrypted by createAndSendMessage
                              createAndSendMessage(decodedNewPassword.c_str(), decodedNewPassword.length(), MSG_TYPE_PASSWORD_UPDATE);
                              
                              // Lock future password changes on this board via mesh
                              passwordChangeLocked = true;
                          }
                      }
                  } else {
                      webFeedbackMessage = "<p class='feedback' style='color:red;'>Error: Invalid or expired session to change password.</p>";
                  }
              }

              client.println(F("HTTP/1.1 303 See Other"));
              String redirectUrl = "/";
              if (isOrganizerRequest) {
                  redirectUrl += "?session_token=" + sessionTokenParam;
              }
              client.println("Location: " + redirectUrl);
              client.println(F("Connection: close"));
              // Added Cache-Control headers for 303 redirect after POST
              client.println(F("Cache-Control: no-cache, no-store, must-revalidate"));
              client.println(F("Pragma: no-cache"));
              client.println(F("Expires: 0"));
              client.println();
              client.stop();
              return;
            }

            // --- HTML Generation for Web Interface ---
            String detectedNodesHtmlContent = "<div class='recent-senders-display-wrapper'><span class='detected-nodes-label'>Senders:</span><div class='detected-nodes-mac-list'>";
            int count = 0;
            portENTER_CRITICAL(&lastSeenPeersMutex); // Use the lastSeenPeers for display
            std::vector<std::pair<String, unsigned long>> sortedSeenPeers;
            for (auto const& [macStr, timestamp] : lastSeenPeers) { sortedSeenPeers.push_back({macStr, timestamp}); }
            std::sort(sortedSeenPeers.begin(), sortedSeenPeers.end(), [](const auto& a, const auto& b) { return a.second > b.second; });

            for (const auto& macPair : sortedSeenPeers) {
                if (count >= 4) break;
                uint8_t macBytes[6];
                unsigned int tempMac[6]; // Temporary array for sscanf
                sscanf(macPair.first.c_str(), "%02X:%02X:%02X:%02X:%02X:%02X",
                       &tempMac[0], &tempMac[1], &tempMac[2], &tempMac[3], &tempMac[4], &tempMac[5]);
                // Copy values from temporary unsigned int array to uint8_t array
                for (int k = 0; k < 6; ++k) {
                    macBytes[k] = (uint8_t)tempMac[k];
                }

                detectedNodesHtmlContent += "<span class='detected-node-item-compact'>" + formatMaskedMac(macBytes) + "</span>";
                count++;
            }
            portEXIT_CRITICAL(&lastSeenPeersMutex);
            if (count == 0) { detectedNodesHtmlContent += "<span class='detected-node-item-compact'>None</span>"; }
            detectedNodesHtmlContent += "</div></div>";

            client.println(F("HTTP/1.1 200 OK"));
            client.println(F("Content-type:text/html"));
            client.println(F("Connection: close"));
            // --- START: Added Cache-Control Headers for main HTML page ---
            client.println(F("Cache-Control: no-cache, no-store, must-revalidate"));
            client.println(F("Pragma: no-cache"));
            client.println(F("Expires: 0"));
            // --- END: Added Cache-Control Headers for main HTML page ---
            client.println();
            client.println(F("<!DOCTYPE html><html><head><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"><title>Protest Info Node</title><style>"));
            client.println(F("body{font-family:Helvetica,Arial,sans-serif;margin:0;padding:0;background-color:#f8f8f8;color:#333;display:flex;flex-direction:column;min-height:100vh;}"));
            client.println(F("header{background-color:#f0f0f0;padding:10px 15px;border-bottom:1px solid #ddd;text-align:center;}"));
            client.println(F("h1,h2,h3{margin:0;padding:5px 0;color:#333;text-align:center;} h1{font-size:1.4em;} h2{font-size:1.2em;} h3{font-size:1.1em;margin-bottom:10px;}"));
            client.println(F("p{margin:3px 0;font-size:0.9em;text-align:center;} .info-line{font-size:0.8em;color:#666;margin-bottom:10px;}"));
            client.println(F(".content-wrapper{display:flex;flex-direction:column;align-items:center;width:100%;max-width:900px;margin:15px auto;padding:0 10px;flex-grow:1;}"));
            client.println(F(".chat-main-content{flex:1;width:100%;max-width:700px;margin:0 auto;background:#fff;padding:15px;border-radius:8px;box-shadow:0 2px 5px rgba(0,0,0,0.1);border:1px solid #ddd;}"));
            client.println(F("pre{background:#eee;padding:10px;border-radius:5px;text-align:left;max-width:100%;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word;font-size:0.85em;border:1px solid #ccc;min-height:200px;}"));
            client.println(F("details, .form-container{background:#fff;padding:15px;border-radius:8px;box-shadow:0 2px 5px rgba(0,0,0,0.1);max-width:450px;margin:15px auto;border:1px solid #ddd;}"));
            client.println(F("summary{font-size:1.1em;font-weight:bold;cursor:pointer;padding:5px 0;text-align:center; outline: none; border: none;} /* Added outline and border none */"));
            client.println(F("form{display:flex;flex-direction:column;align-items:center;margin-top:10px;}"));
            client.println(F("label{font-size:0.9em;margin-bottom:5px;align-self:flex-start;width:80%;}"));
            client.println(F("input[type=text],input[type=password]{width:80%;max-width:350px;padding:8px;margin-bottom:10px;border-radius:4px;border:1px solid #ccc;font-size:0.9em;}"));
            client.println(F("input[type=submit], .button-link{background-color:#007bff;color:white!important;padding:8px 15px;border:none;border-radius:4px;cursor:pointer;font-size:1em;transition:background-color 0.3s ease;text-decoration:none;display:block; margin: 0 auto;}"));
            client.println(F(".button-link.secondary{background-color:#6c757d;} .button-link.secondary:hover{background-color:#5a6268;}"));
            client.println(F(".recent-senders-display-wrapper{display:flex;flex-direction:column;align-items:center;width:100%;max-width:450px;background:#e6f7ff;border:1px solid #cceeff;border-radius:12px;padding:10px 15px;font-size:0.75em;color:#0056b3;margin:15px auto;}"));
            client.println(F(".detected-nodes-label{font-weight:bold;margin-bottom:5px;color:#003366;}"));
            client.println(F(".detected-nodes-mac-list{display:flex;flex-wrap:wrap;justify-content:center;gap:8px;width:100%;}"));
            client.println(F("</style></head><body><script>"));
            // Re-added simpleHash function to client-side JS
            client.println(F("function simpleHash(input) {"));
            client.println(F("    let hash = 5381;"));
            client.println(F("    for (let i = 0; i < input.length; i++) {"));
            client.println(F("        hash = ((hash << 5) + hash) + input.charCodeAt(i);"));
            client.println(F("    }"));
            client.println(F("    return (hash >>> 0).toString(16); // Ensure positive and convert to hex"));
            client.println(F("}"));
            client.println(F("async function fetchChallengeAndSubmit() {"));
            client.println(F("    const loginForm = document.getElementById('organizerLoginForm');"));
            client.println(F("    const passwordInput = document.getElementById('pass_input');"));
            client.println(F("    const challengeNonceInput = document.getElementById('challenge_nonce_input');"));
            client.println(F("    const passwordResponseHashInput = document.getElementById('password_response_hash_input');"));
            client.println(F("    if (!loginForm || !passwordInput || !challengeNonceInput || !passwordResponseHashInput) {"));
            client.println(F("        console.error('Login form elements not found.');"));
            client.println(F("        const feedbackDiv = document.createElement('p');"));
            client.println(F("        feedbackDiv.className = 'feedback';"));
            client.println(F("        feedbackDiv.style.color = 'red';"));
            client.println(F("        feedbackDiv.textContent = 'Login failed: Missing form elements. Please refresh the page.';"));
            client.println(F("        loginForm.parentNode.insertBefore(feedbackDiv, loginForm);"));
            client.println(F("        return;"));
            client.println(F("    }"));
            client.println(F("    console.log('Attempting to fetch challenge and submit form...');"));
            client.println(F("    try {"));
            client.println(F("        console.log('Fetching challenge nonce from /challenge...');"));
            client.println(F("        const response = await fetch('/challenge');"));
            client.println(F("        if (!response.ok) {"));
            client.println(F("            throw new Error(`HTTP error! status: ${response.status}`);"));
            client.println(F("        }"));
            client.println(F("        const nonce = await response.text();"));
            client.println(F("        challengeNonceInput.value = nonce;"));
            client.println(F("        console.log('Received nonce:', nonce);"));
            client.println(F("        const plaintextPassword = passwordInput.value;"));
            client.println(F("        // Corrected client-side hashing: hash the plaintext password, then hash with nonce"));
            client.println(F("        const hashedClientPassword = simpleHash(plaintextPassword);"));
            client.println(F("        const combinedString = hashedClientPassword + nonce;"));
            client.println(F("        const responseHash = simpleHash(combinedString);"));
            client.println(F("        passwordResponseHashInput.value = responseHash;"));
            client.println(F("        console.log('Generated hash:', responseHash);"));
            client.println(F("        passwordInput.value = ''; // Clear plaintext password from input for security"));
            client.println(F("        console.log('Submitting form...');"));
            client.println(F("        loginForm.submit();"));
            client.println(F("    } catch (error) {"));
            client.println(F("        console.error('Authentication process failed:', error);"));
            client.println(F("        const feedbackDiv = document.createElement('p');"));
            client.println(F("        feedbackDiv.className = 'feedback';"));
            client.println(F("        feedbackDiv.style.color = 'red';"));
            client.println(F("        feedbackDiv.textContent = 'Login failed: ' + error.message + '. Please try again.';"));
            client.println(F("        loginForm.parentNode.insertBefore(feedbackDiv, loginForm);"));
            client.println(F("    }"));
            client.println(F("}"));
            client.println(F("document.addEventListener('DOMContentLoaded', () => {"));
            client.println(F("    const loginForm = document.getElementById('organizerLoginForm');"));
            client.println(F("    if (loginForm) {"));
            client.println(F("        loginForm.addEventListener('submit', (event) => {"));
            client.println(F("            event.preventDefault(); // Prevent default form submission"));
            client.println(F("            fetchChallengeAndSubmit(); // Initiate challenge-response and submit"));
            client.println(F("        });"));
            client.println(F("    }"));
            client.println(F("    // Scroll to the top of the pre element on load for newest messages visibility"));
            client.println(F("    const preElement = document.querySelector('pre');"));
            client.println(F("    if (preElement) {"));
            client.println(F("        preElement.scrollTop = 0;"));
            client.println(F("    }"));
            client.println(F("});"));
            client.println(F("</script>"));
            client.println(F("<body><header><h1>Protest Information Node</h1>"));
            client.printf("<p class='info-line'><strong>IP:</strong> %s | <strong>MAC:</strong> %s</p>", IP.toString().c_str(), MAC_suffix_str.c_str());
            client.println(F("<p style='font-weight:bold; color:#007bff; margin-top:10px;'>All protest activities are non-violent.</p>"));
            if (publicMessagingEnabled) {
                client.println(F("<p class='feedback' style='color:orange;'>Warning: Public messages are unmoderated.</p>"));
            }
            client.println(F("</header>"));
            client.println(F("<div class='content-wrapper'><div class='chat-main-content'>"));

            if (webFeedbackMessage.length() > 0) { client.println(webFeedbackMessage); webFeedbackMessage = ""; }

            bool showPublicView = (requestedPath.indexOf("?show_public=true") != -1);
            
            String displayedBuffer;
            portENTER_CRITICAL(&localDisplayLogMutex);
            for (const auto& entry : localDisplayLog) {
                const auto& msg = entry.message;
                String formattedLine = "Node " + getMacSuffix(msg.originalSenderMac) + " - ";
                if (msg.messageType == MSG_TYPE_ORGANIZER) formattedLine += "Organizer: ";
                else if (msg.messageType == MSG_TYPE_PUBLIC) formattedLine += "Public: ";
                else if (msg.messageType == MSG_TYPE_COMMAND) formattedLine += "Command: ";
                else if (msg.messageType == MSG_TYPE_AUTO_INIT) formattedLine += "Auto: ";
                formattedLine += String(msg.content);

                if(formattedLine.indexOf("Public: ") != -1 && !showPublicView) { /* skip */ }
                else {
                    displayedBuffer += escapeHtml(formattedLine) + "\n";
                }
            }
            portEXIT_CRITICAL(&localDisplayLogMutex);

            client.println(F("<h2>Serial Data Log:</h2><h3 style='font-size:0.9em; margin-top:0; color:#555;'>Most recent messages at the top.</h3><pre>"));
            client.print(displayedBuffer);
            client.println(F("</pre>"));

            if (publicMessagingEnabled) {
                client.println(F("<div style='text-align:center; margin: 15px;'>"));
                String publicLink = showPublicView ? "/" : "/?show_public=true";
                if (isOrganizerRequest) { publicLink += (showPublicView ? "?" : "&") + String("session_token=") + sessionTokenParam; }
                client.print("<a href='" + publicLink + "' class='button-link" + (showPublicView ? " secondary" : "") + "'>");
                client.print(showPublicView ? "Hide Public Messages" : "Show Public Messages");
                client.println("</a></div>");
            }

            if(isOrganizerRequest) {
                client.println(F("<details open><summary>Organizer Controls</summary>"));
                client.println(F("<div class='form-container' style='box-shadow:none;border:none;padding-top:5px;'>"));
                client.println(F("<h3>Send Organizer Message:</h3><form action='/' method='POST'><input type='hidden' name='action' value='sendMessage'>"));
                client.printf("<input type='hidden' name='session_token' value='%s'>", sessionTokenParam.c_str());
                client.println(F("<label for='msg_input'>Message:</label><input type='text' id='msg_input' name='message' required maxlength='226'>"));
                client.println(F("<div style='display:flex;align-items:center;justify-content:center;width:80%;margin-bottom:10px;'><input type='checkbox' id='urgent_input' name='urgent' value='on' style='margin-right:8px;'><label for='urgent_input' style='margin-bottom:0;'>Urgent</label></div>"));
                client.println(F("<input type='submit' value='Send Message'></form></div>"));

                client.println(F("<div class='form-container' style='box-shadow:none;border:none;padding-top:5px;margin-top:5px;'><h3>Admin Actions</h3>"));
                client.println(F("<form action='/' method='POST' style='flex-direction:row;justify-content:center;gap:10px;'>"));
                client.println(F("<input type='hidden' name='action' value='rebroadcastCache'>"));
                client.printf("<input type='hidden' name='session_token' value='%s'>", sessionTokenParam.c_str());
                client.println(F("<input type='submit' value='Re-broadcast Cache'></form>"));
                client.println(F("<form action='/' method='POST' style='flex-direction:row;justify-content:center;gap:10px;margin-top:10px;'>"));
                client.println(F("<input type='hidden' name='action' value='togglePublic'>"));
                client.printf("<input type='hidden' name='session_token' value='%s'>", sessionTokenParam.c_str());
                client.print(F("<input type='submit' value='"));
                client.print(publicMessagingEnabled ? "Disable Public Msgs" : "Enable Public Msgs");
                client.println(F("'></form>"));
                
                // New Password Reset Section
                // Changed class for summary to remove button-link styling and added custom style for consistency
                client.println(F("<details style='margin-top:10px;'><summary style='font-size:1.1em;font-weight:bold;cursor:pointer;padding:5px 0;text-align:center; outline: none; border: none;'>Reset Organizer Password</summary><div class='form-container' style='box-shadow:none;border:none;padding-top:5px;'>"));
                client.println(F("<h3>Set New Organizer Password:</h3><form action='/' method='POST'><input type='hidden' name='action' value='setOrganizerPassword'>"));
                client.printf("<input type='hidden' name='session_token' value='%s'>", sessionTokenParam.c_str());
                client.println(F("<label for='new_pass_input'>New Password:</label><input type='password' id='new_pass_input' name='new_password' required>"));
                client.println(F("<input type='submit' value='Set New Password' class='button-link' style='background-color:#007bff;'></form></div></details>"));

                client.println(F("<form action='/' method='POST' style='margin-top:10px;'><input type='hidden' name='action' value='exitOrganizer'>"));
                client.printf("<input type='hidden' name='session_token' value='%s'>", sessionTokenParam.c_str());
                client.println(F("<input type='submit' value='Exit Organizer Mode' class='button-link secondary' style='background-color:#dc3545;'></form>"));
                client.println(F("</div></details>"));
            } else {
                client.println(F("<details><summary>Enter Organizer Mode</summary><div class='form-container' style='box-shadow:none;border:none;padding-top:5px;'>"));
                client.println(F("<form id='organizerLoginForm' action='/' method='POST'><input type='hidden' name='action' value='enterOrganizer'>"));
                client.println(F("<input type='hidden' id='challenge_nonce_input' name='challenge_nonce' value=''>"));
                client.println(F("<input type='hidden' id='password_response_hash_input' name='password_response_hash' value=''>"));
                client.println(F("<label for='pass_input'>Password:</label><input type='password' id='pass_input' name='password_plaintext_client' required>"));
                client.println(F("<input type='submit' value='Enter Mode'></form></div></details>"));
                if(publicMessagingEnabled) {
                    client.println(F("<details><summary>Send a Public Message</summary><div class='form-container' style='box-shadow:none;border:none;padding-top:5px;'>"));
                    client.println(F("<h3>Message (no password required):</h3><form action='/' method='POST'><input type='hidden' name='action' value='sendPublicMessage'>"));
                    client.println(F("<label for='pub_msg_input'>Message:</label><input type='text' id='pub_msg_input' name='message' required maxlength='226'>"));
                    client.println(F("<input type='submit' value='Send Public Message'></form></div></details>"));
                }
            }

            client.print(detectedNodesHtmlContent);
            client.println(F("</div></div></body></html>"));
            break;
          } else {
            if (currentLine.startsWith("GET")) {
              isPost = false;
              int pathStart = currentLine.indexOf(' ') + 1;
              int pathEnd = currentLine.indexOf(' ', pathStart);
              if (pathStart != -1 && pathEnd != -1 && pathEnd > pathStart) {
                requestedPath = currentLine.substring(pathStart, pathEnd);
              }
            } else if (currentLine.startsWith("POST")) {
              isPost = true;
            }
            if (currentLine.startsWith("Content-Length: ")) {
              contentLength = currentLine.substring(16).toInt();
              if (contentLength > 2048) {
                  Serial.printf("Error: Excessive Content-Length (%d). Closing connection to prevent DoS.\n", contentLength);
                  client.stop();
                  return;
              }
            }
            currentLine = "";
          }
        } else if (c != '\r') {
          currentLine += c;
        }
      }
    }
    client.stop();
  }

  if (userMessageBuffer.length() > 0) {
    String messageContent = userMessageBuffer;
    uint8_t messageType = MSG_TYPE_PUBLIC; // Default to public if not set by organizer
    if (messageContent.startsWith("Urgent: ")) {
        totalUrgentMessages++;
        messageType = MSG_TYPE_ORGANIZER; // Assuming urgent messages are from organizer
    } else if (messageContent.startsWith("Public: ")) {
        messageType = MSG_TYPE_PUBLIC;
    } else {
        // If it's not prefixed, and it's from the user buffer, it's a public message
        messageType = MSG_TYPE_PUBLIC;
    }

    createAndSendMessage(messageContent.c_str(), messageContent.length(), messageType);
    userMessageBuffer = "";
  }

#if USE_DISPLAY
  // Dedicated display refresh logic
  if (millis() - lastDisplayRefresh >= DISPLAY_REFRESH_INTERVAL_MS) {
    lastDisplayRefresh = millis();
    if (currentDisplayMode == MODE_CHAT_LOG) {
      displayChatLogMode(22);
    } else if (currentDisplayMode == MODE_URGENT_ONLY) {
      displayUrgentOnlyMode(22);
    } else if (currentDisplayMode == MODE_DEVICE_INFO) {
      displayDeviceInfoMode();
    } else if (currentDisplayMode == MODE_STATS_INFO) {
      displayStatsInfoMode();
    }
  }

  if (digitalRead(TFT_TOUCH_IRQ_PIN) == LOW && (millis() - lastTouchTime > TOUCH_DEBOUNCE_MS)) {
    lastTouchTime = millis();
    Serial.println("Touch detected! Switching display mode.");

    if (currentDisplayMode == MODE_CHAT_LOG) {
      currentDisplayMode = MODE_URGENT_ONLY;
      displayUrgentOnlyMode(22);
    } else if (currentDisplayMode == MODE_URGENT_ONLY) {
      currentDisplayMode = MODE_DEVICE_INFO;
      displayDeviceInfoMode();
    } else if (currentDisplayMode == MODE_DEVICE_INFO) {
      currentDisplayMode = MODE_STATS_INFO;
      displayStatsInfoMode();
    }
    else {
      currentDisplayMode = MODE_CHAT_LOG;
      displayChatLogMode(22);
    }
    // Force a display refresh immediately after mode change
    lastDisplayRefresh = 0; // Reset timer to trigger immediate refresh
  }
#endif
}

#if USE_DISPLAY
void displayChatLogMode(int numLines) {
  tft.fillScreen(TFT_BLACK);
  tft.setCursor(0, 0);
  tft.setTextColor(TFT_GREEN);      tft.println("MAC: " + MAC_full_str);
  tft.setTextColor(TFT_GREEN);     tft.println("IP: " + IP.toString());
  tft.setTextColor(TFT_GREEN);      tft.println("Mode: All Messages");
  tft.setTextColor(TFT_WHITE);     tft.println("----------------------");
  
  portENTER_CRITICAL(&localDisplayLogMutex);
  int linesPrinted = 0;
  // Iterate through localDisplayLog (which is sorted newest first)
  for (const auto& entry : localDisplayLog) {
    if (linesPrinted >= numLines) break;
    const auto& msg = entry.message;
    String formattedLine = "Node " + getMacSuffix(msg.originalSenderMac) + " - ";
    if (msg.messageType == MSG_TYPE_ORGANIZER) formattedLine += "Organizer: ";
    else if (msg.messageType == MSG_TYPE_PUBLIC) formattedLine += "Public: ";
    else if (msg.messageType == MSG_TYPE_COMMAND) formattedLine += "Command: ";
    else if (msg.messageType == MSG_TYPE_AUTO_INIT) formattedLine += "Auto: ";
    formattedLine += String(msg.content);

    // Ensure password update messages are not displayed
    if (msg.messageType == MSG_TYPE_PASSWORD_UPDATE) { // MODIFIED: Added check to skip display for password updates
        continue; 
    }
    tft.println(formattedLine);
    linesPrinted++;
  }
  portEXIT_CRITICAL(&localDisplayLogMutex);
}

void displayUrgentOnlyMode(int numLines) {
  tft.fillScreen(TFT_BLACK);
  tft.setCursor(0, 0);
  tft.setTextColor(TFT_GREEN);      tft.println("MAC: " + MAC_full_str);
  tft.setTextColor(TFT_GREEN);     tft.println("IP: " + IP.toString());
  tft.setTextColor(TFT_GREEN);        tft.println("Mode: Urgent Only");
  tft.setTextColor(TFT_WHITE);     tft.println("----------------------");

  portENTER_CRITICAL(&localDisplayLogMutex);
  int linesPrinted = 0;
  for (const auto& entry : localDisplayLog) {
    if (linesPrinted >= numLines) break;
    const auto& msg = entry.message;
    if (String(msg.content).indexOf("Urgent: ") != -1) { // Check content for "Urgent: " prefix
        String formattedLine = "Node " + getMacSuffix(msg.originalSenderMac) + " - ";
        if (msg.messageType == MSG_TYPE_ORGANIZER) formattedLine += "Organizer: "; // Still include type for display
        formattedLine += String(msg.content);
        tft.println(formattedLine);
        linesPrinted++;
    }
  }
  portEXIT_CRITICAL(&localDisplayLogMutex);
}

void displayDeviceInfoMode() {
  tft.fillScreen(TFT_BLACK);
  tft.setCursor(0, 0);
  tft.setTextColor(TFT_GREEN);      tft.println("MAC: " + MAC_full_str);
  tft.setTextColor(TFT_GREEN);     tft.println("IP: " + IP.toString());
  tft.setTextColor(TFT_GREEN);      tft.println("Mode: Device Info");

  tft.setTextColor(TFT_WHITE);     tft.println("----------------------");
  tft.println("Nearby Nodes (Last Seen):");

  portENTER_CRITICAL(&lastSeenPeersMutex); // Use the lastSeenPeers for display
  std::vector<std::pair<String, unsigned long>> sortedSeenPeers;
  for (auto const& [macStr, timestamp] : lastSeenPeers) { sortedSeenPeers.push_back({macStr, timestamp}); }
  std::sort(sortedSeenPeers.begin(), sortedSeenPeers.end(), [](const auto& a, const auto& b) { return a.second > b.second; });

  int linesPrinted = 0;
  const int MAX_NODES_TO_DISPLAY = 15;
  if (sortedSeenPeers.empty()) {
    tft.println("  No other nodes detected yet.");
  } else {
    for (const auto& macPair : sortedSeenPeers) {
        if (linesPrinted >= MAX_NODES_TO_DISPLAY) break;
        uint8_t macBytes[6];
        unsigned int tempMac[6]; // Temporary array for sscanf
        sscanf(macPair.first.c_str(), "%02X:%02X:%02X:%02X:%02X:%02X",
               &tempMac[0], &tempMac[1], &tempMac[2], &tempMac[3], &tempMac[4], &tempMac[5]);
        // Copy values from temporary unsigned int array to uint8_t array
        for (int k = 0; k < 6; ++k) {
            macBytes[k] = (uint8_t)tempMac[k];
        }

        tft.printf("  %s (seen %lu s ago)\n", formatMaskedMac(macBytes).c_str(), (millis() - macPair.second) / 1000);
        linesPrinted++;
    }
  }
  portEXIT_CRITICAL(&lastSeenPeersMutex);
}

void displayStatsInfoMode() {
  tft.fillScreen(TFT_BLACK);
  tft.setCursor(0, 0);
  tft.setTextColor(TFT_GREEN);      tft.println("MAC: " + MAC_full_str);
  tft.setTextColor(TFT_GREEN);     tft.println("IP: " + IP.toString());
  tft.setTextColor(TFT_GREEN);      tft.println("Mode: Stats Info");
  tft.setTextColor(TFT_WHITE);     tft.println("----------------------");

  unsigned long uptimeMillis = millis();
  unsigned long seconds = uptimeMillis / 1000;
  unsigned long minutes = seconds / 60;
  unsigned long hours = minutes / 60;
  unsigned long days = hours / 24;
  seconds %= 60; minutes %= 60; hours %= 24;

  tft.println("Uptime:");
  tft.printf("  Days: %lu, H: %lu, M: %lu, S: %lu\n", days, hours, minutes, seconds);
  tft.println("");

  tft.println("Message Stats:");
  tft.printf("  Total Sent: %lu\n", totalMessagesSent);
  tft.printf("  Total Received: %lu\n", totalMessagesReceived);
  tft.printf("  Urgent Messages: %lu\n", totalUrgentMessages);
  tft.printf("  Cache Size: %u/%u\n", seenMessages.size(), MAX_CACHE_SIZE);

  tft.println("");
  tft.println("Mode Status:");
  tft.printf("  Public Msgs: %s\n", publicMessagingEnabled ? "ENABLED" : "DISABLED");
}
#endif
