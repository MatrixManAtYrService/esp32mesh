#include <WiFi.h>
#include <esp_now.h>
#include <esp_wifi.h> // Include for esp_wifi_set_channel
#include <vector>     // For dynamic array for the cache
#include <chrono>     // For timestamping cache entries
#include <algorithm>  // For std::remove_if, std::min_element
#include <string.h>   // For strncpy and memset

#define USE_DISPLAY true
#if USE_DISPLAY
#include <TFT_eSPI.h>
TFT_eSPI tft = TFT_eSPI();
bool displayActive = false;
#endif

// Hard-coded password for web input
const char* WEB_PASSWORD = "password"; // The password for accessing the message input

// Trusted MACs are now used for both receive and send authorization
// For simplicity, we are assuming all ESP32s in your network will be peers.
// Replace these with the actual MAC addresses of all your ESP32 nodes.
// Example: {0x14, 0x33, 0x5C, 0x06, 0x3A, 0x99} for 14:33:5C:06:3A:99
const uint8_t trustedMACs[][6] = {
  {0x08, 0xA6, 0xF7, 0x47, 0xFA, 0xAD},    // MAC of node A (example, keep if correct for your setup)
  {0x14, 0x33, 0x5C, 0x6D, 0x74, 0x05},    // MAC of node B
  {0x14, 0x33, 0x5C, 0x6C, 0x3A, 0x99}     // MAC of node C
  // Add all other ESP32 MAC addresses here, ensuring they are exact!
};
const int numTrusted = sizeof(trustedMACs) / sizeof(trustedMACs[0]);


// Define a consistent channel for both SoftAP and ESP-NOW
// Channel 1 is a common default and good starting point.
const int WIFI_CHANNEL = 1;

WiFiServer server(80);
IPAddress IP;
String MAC_full_str; // Full MAC address of this ESP32 (e.g., "AA:BB:CC:DD:EE:FF")
String MAC_suffix_str; // Last 4 chars of our MAC (e.g., "EEFF")
String ssid; // Our unique SSID

String serialBuffer = "";       // Stores messages, most recent on top
String userMessageBuffer = "";  // To hold the user-entered message from POST
String webFeedbackMessage = ""; // To send messages back to the web client (e.g., success/error)

unsigned long lastUpdate = 0;
int counter = 1;

// --- Message Structure for ESP-NOW and Deduplication ---
// This struct will be used to send and receive messages,
// ensuring each message has a unique ID and original sender MAC.
// Message content size should be 240 bytes (max 250 bytes - 10 for ID/MAC).
// If you change content size, update MAX_MESSAGE_CONTENT_LEN
#define MAX_MESSAGE_CONTENT_LEN 240
typedef struct __attribute__((packed)) {
  uint32_t messageID;       // Unique ID for the message
  uint8_t originalSenderMac[6]; // MAC address of the *original* sender
  char content[MAX_MESSAGE_CONTENT_LEN]; // Message content
} esp_now_message_t;

// --- Cache for Deduplication ---
struct SeenMessage {
  uint32_t messageID;
  uint8_t originalSenderMac[6];
  unsigned long timestamp; // When this message was last seen/processed
};

// Global vector for seen messages and mutex for thread-safe access
// IMPORTANT: Using a mutex for `seenMessages` as it's accessed from ISR context (`onDataRecv`)
// and the main loop.
std::vector<SeenMessage> seenMessages;
portMUX_TYPE seenMessagesMutex = portMUX_INITIALIZER_UNLOCKED;

const unsigned long DEDUP_CACHE_DURATION_MS = 10000; // How long to keep a message in cache (10 seconds)
const size_t MAX_CACHE_SIZE = 50; // Max number of messages to keep in cache

// --- FreeRTOS Queue for message processing ---
QueueHandle_t messageQueue;
#define QUEUE_SIZE 10 // Max messages to queue

// --- FORWARD DECLARATION for displayLastLines ---
#if USE_DISPLAY
void displayLastLines(int numLines);
#endif
// --- END FORWARD DECLARATION ---

// Helper function to format a byte array MAC address into a String (full MAC)
String formatMac(const uint8_t *mac) {
  char buf[18];
  snprintf(buf, sizeof(buf), "%02X:%02X:%02X:%02X:%02X:%02X",
           mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  return String(buf);
}

// Helper function to get the 4-char suffix from a byte array MAC
String getMacSuffix(const uint8_t *mac) {
  char buf[5]; // 4 chars + null terminator
  snprintf(buf, sizeof(buf), "%02X%02X", mac[4], mac[5]); // Last two bytes (4 hex chars)
  return String(buf);
}


// Function to check if a message is already in the seenMessages cache
bool isMessageSeen(uint32_t id, const uint8_t* mac) {
  // Lock the mutex before accessing the shared resource
  portENTER_CRITICAL(&seenMessagesMutex);
  bool found = false;
  for (const auto& msg : seenMessages) {
    if (msg.messageID == id && memcmp(msg.originalSenderMac, mac, 6) == 0) {
      found = true;
      break;
    }
  }
  // Unlock the mutex
  portEXIT_CRITICAL(&seenMessagesMutex);
  return found;
}

// Function to add a message to the seenMessages cache
void addMessageToSeen(uint32_t id, const uint8_t* mac) {
  // Lock the mutex before accessing the shared resource
  portENTER_CRITICAL(&seenMessagesMutex);

  // Remove old entries first
  unsigned long currentTime = millis();
  seenMessages.erase(std::remove_if(seenMessages.begin(), seenMessages.end(),
                                     [currentTime](const SeenMessage& msg) {
                                         return (currentTime - msg.timestamp) > DEDUP_CACHE_DURATION_MS;
                                     }),
                      seenMessages.end());

  // If cache is full, remove the oldest one before adding new
  if (seenMessages.size() >= MAX_CACHE_SIZE) {
    // Find the oldest message (smallest timestamp)
    auto oldest = std::min_element(seenMessages.begin(), seenMessages.end(),
                                   [](const SeenMessage& a, const SeenMessage& b) {
                                       return a.timestamp < b.timestamp;
                                   });
    if (oldest != seenMessages.end()) {
        seenMessages.erase(oldest);
    }
  }

  SeenMessage newMessage = {id, {0}, currentTime};
  memcpy(newMessage.originalSenderMac, mac, 6);
  seenMessages.push_back(newMessage);

  // Unlock the mutex
  portEXIT_CRITICAL(&seenMessagesMutex);
}


// Callback function when ESP-NOW data is received
// IMPORTANT: Keep this function as lean as possible!
void onDataRecv(const esp_now_recv_info *recvInfo, const uint8_t *data, int len) {
  // Basic validation of message length
  if (len != sizeof(esp_now_message_t)) {
    // Serial.println("Received malformed ESP-NOW message (wrong size)"); // Cannot print from ISR directly
    return;
  }

  esp_now_message_t incomingMessage;
  // Use memset to clear the structure before copying to avoid junk data,
  // especially if the received 'len' is smaller than the struct (though we check 'len').
  memset(&incomingMessage, 0, sizeof(esp_now_message_t));
  memcpy(&incomingMessage, data, sizeof(esp_now_message_t));
  // Ensure null-termination of the content, as memcpy doesn't guarantee it if source isn't null-terminated
  // or if the source is exactly MAX_MESSAGE_CONTENT_LEN long.
  incomingMessage.content[MAX_MESSAGE_CONTENT_LEN - 1] = '\0';

  // Check if already seen based on ID and original sender MAC
  if (isMessageSeen(incomingMessage.messageID, incomingMessage.originalSenderMac)) {
    return; // Duplicate message, discard.
  }
  
  // Add to seen messages cache immediately
  addMessageToSeen(incomingMessage.messageID, incomingMessage.originalSenderMac);

  // If not a duplicate, push to queue for processing in loop()
  // Use xQueueSendFromISR for ISR context
  BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  if (xQueueSendFromISR(messageQueue, &incomingMessage, &xHigherPriorityTaskWoken) != pdPASS) {
    // Message dropped due to queue full. Can't print from ISR.
  }
  if (xHigherPriorityTaskWoken == pdTRUE) {
    portYIELD_FROM_ISR(); // Yield to a higher priority task if one was unblocked
  }
}


// Sends a message to all trusted ESP-NOW peers
void sendToAllPeers(const esp_now_message_t &message) {
  uint8_t currentMacBytes[6];
  // Convert our own MAC_full_str to bytes for comparison
  sscanf(MAC_full_str.c_str(), "%02X:%02X:%02X:%02X:%02X:%02X", 
         (unsigned int*)&currentMacBytes[0], (unsigned int*)&currentMacBytes[1], 
         (unsigned int*)&currentMacBytes[2], (unsigned int*)&currentMacBytes[3], 
         (unsigned int*)&currentMacBytes[4], (unsigned int*)&currentMacBytes[5]);


  for (int i = 0; i < numTrusted; i++) {
    // Prevent sending back to the original sender to avoid loops in the mesh.
    // Also, don't send to ourselves if we are the original sender (to avoid sending it back to us,
    // although our local addMessageToSeen already handles our own messages as "seen").
    if (memcmp(trustedMACs[i], message.originalSenderMac, 6) != 0 || memcmp(trustedMACs[i], currentMacBytes, 6) != 0) {
      esp_err_t result = esp_now_send(trustedMACs[i], (uint8_t*)&message, sizeof(esp_now_message_t));
      if (result != ESP_OK)
        Serial.printf("Send to %s failed (err %d)\n", formatMac(trustedMACs[i]).c_str(), result);
      else
        Serial.printf("Sent to %s: %s\n", formatMac(trustedMACs[i]).c_str(), message.content);
    } else {
        // Serial.printf("Skipping send to original sender or self: %s\n", formatMac(trustedMACs[i]).c_str());
    }
  }
}

void setup() {
  Serial.begin(115200);

  // Create the FreeRTOS message queue
  messageQueue = xQueueCreate(QUEUE_SIZE, sizeof(esp_now_message_t));
  if (messageQueue == NULL) {
    Serial.println("Failed to create message queue!");
    // Handle error, maybe halt
    while(true) { delay(100); } // Halt if queue creation fails
  }

  // Set up WiFi as Access Point + Station (for ESP-NOW and serving web page)
  WiFi.mode(WIFI_AP_STA);
  // Disable WiFi sleep to ensure ESP-NOW can always receive packets
  WiFi.setSleep(false);

  // --- Explicitly configure SoftAP channel and ensure consistency ---
  // Step 1: Set a temporary AP to get the MAC address.
  // We use the WIFI_CHANNEL constant here from the start.
  WiFi.softAP("placeholder", nullptr, WIFI_CHANNEL);
  delay(100);
  MAC_full_str = WiFi.softAPmacAddress(); // Get our own full MAC address
  
  // Calculate our MAC suffix once at startup
  String macCleanForSuffix = MAC_full_str;
  macCleanForSuffix.replace(":", "");
  MAC_suffix_str = macCleanForSuffix.substring(macCleanForSuffix.length() - 4);

  ssid = "ProtestInfo_" + MAC_suffix_str;

  // Step 2: Configure the actual SoftAP with the unique SSID and the chosen channel.
  // This is the definitive setting for the SoftAP channel.
  WiFi.softAP(ssid.c_str(), nullptr, WIFI_CHANNEL);
  IP = WiFi.softAPIP(); // Get the IP address of our AP
  server.begin(); // Start the web server

  // Step 3: Crucially, ensure the underlying Wi-Fi station interface (used by ESP-NOW)
  // is also locked to the same channel. This helps avoid internal channel conflicts.
  esp_wifi_set_channel(WIFI_CHANNEL, WIFI_SECOND_CHAN_NONE);

#if USE_DISPLAY
  tft.begin();
  tft.setRotation(1); // Adjust for your specific display orientation
  tft.fillScreen(TFT_BLACK);
  tft.setTextColor(TFT_YELLOW, TFT_BLACK);
  tft.setTextSize(1);
  tft.setCursor(0, 0);
  tft.println("Starting node...");
  displayActive = true;
  Serial.println("Display initialized");
#endif

  // Initialize ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("ESP-NOW init failed");
    while(true) { delay(100); } // Halt if ESP-NOW init fails
  }

  // Add trusted peers for sending messages
  for (int i = 0; i < numTrusted; i++) {
    esp_now_del_peer(trustedMACs[i]); // Remove if already exists
    esp_now_peer_info_t peer{}; // Use aggregate initialization for clarity
    memcpy(peer.peer_addr, trustedMACs[i], 6);
    // Peer channel MUST match the SoftAP channel (WIFI_CHANNEL)
    peer.channel = WIFI_CHANNEL;
    peer.encrypt = false;    // No encryption for simplicity in this example
    esp_err_t result = esp_now_add_peer(&peer);
    if (result == ESP_OK)
      Serial.println("Peer added: " + formatMac(trustedMACs[i]));
    else
      Serial.printf("Failed to add peer %s (err %d)\n", formatMac(trustedMACs[i]).c_str(), result);
  }

  // Register the receive callback function
  esp_now_register_recv_cb(onDataRecv);
}

void loop() {
  // --- Process Incoming Messages from Queue ---
  esp_now_message_t receivedMessage;
  while (xQueueReceive(messageQueue, &receivedMessage, 0) == pdPASS) {
    // Ensure content is null-terminated before using with String, just in case
    receivedMessage.content[MAX_MESSAGE_CONTENT_LEN - 1] = '\0';
    String incomingContent = String(receivedMessage.content);
    String originalSenderMacSuffix = getMacSuffix(receivedMessage.originalSenderMac); // Use new helper

    String formattedIncoming = String("[") + String(receivedMessage.messageID, HEX) + "] Node " + originalSenderMacSuffix + " - " + incomingContent;
    
    // Prepend new messages to buffer (most recent on top)
    serialBuffer = formattedIncoming + "\n" + serialBuffer;
    if (serialBuffer.length() > 4000) // Keep buffer from growing too large
      serialBuffer = serialBuffer.substring(0, 4000); // Take the most recent 4000 chars
    Serial.println("Message received from queue: " + formattedIncoming);

#if USE_DISPLAY
    if (displayActive) displayLastLines(22);
#endif

    // Re-broadcast the message to other peers (mesh behavior)
    sendToAllPeers(receivedMessage);
  }


  // Periodically send an auto-generated message (if no user message is pending)
  if (millis() - lastUpdate >= 5000) {
    lastUpdate = millis();
    
    // Only send the automatically generated message if there's no user input pending
    if (userMessageBuffer.length() == 0) {
      esp_now_message_t autoMessage;
      // It's good practice to clear the struct before populating, especially char arrays
      memset(&autoMessage, 0, sizeof(esp_now_message_t)); 

      autoMessage.messageID = esp_random();
      uint8_t selfMac[6];
      // Convert our own MAC_full_str to bytes
      sscanf(MAC_full_str.c_str(), "%02X:%02X:%02X:%02X:%02X:%02X", 
             (unsigned int*)&selfMac[0], (unsigned int*)&selfMac[1], 
             (unsigned int*)&selfMac[2], (unsigned int*)&selfMac[3], 
             (unsigned int*)&selfMac[4], (unsigned int*)&selfMac[5]);
      memcpy(autoMessage.originalSenderMac, selfMac, 6);
      
      char msgContentBuf[MAX_MESSAGE_CONTENT_LEN]; // Use a temporary buffer for snprintf
      snprintf(msgContentBuf, sizeof(msgContentBuf), "\"Auto Message %d\"", counter);
      
      // Copy content from temporary buffer to struct, ensuring null termination
      strncpy(autoMessage.content, msgContentBuf, sizeof(autoMessage.content));
      autoMessage.content[sizeof(autoMessage.content) - 1] = '\0'; // Explicitly ensure null termination

      String formattedMessage = String("[") + String(autoMessage.messageID, HEX) + "] Node " + MAC_suffix_str + " - " + String(autoMessage.content);

      // Add to seen messages cache immediately (so we don't process our own broadcast as an incoming message)
      addMessageToSeen(autoMessage.messageID, autoMessage.originalSenderMac);

      // Prepend new messages to buffer (most recent on top)
      serialBuffer = formattedMessage + "\n" + serialBuffer; // Prepend here
      Serial.println("Sending (Auto): " + formattedMessage);
      counter++;

      if (serialBuffer.length() > 4000) // Keep buffer manageable
        serialBuffer = serialBuffer.substring(0, 4000); // Truncate from the end

      sendToAllPeers(autoMessage); // Send via ESP-NOW

#if USE_DISPLAY
      if (displayActive) displayLastLines(22);
#endif
    }
  }

  // Handle incoming HTTP client requests
  WiFiClient client = server.available();
  if (client) {
    String currentLine = "";
    String postBody = "";
    bool isPost = false;
    unsigned long clientTimeout = millis(); // Timeout for reading client data
    int contentLength = 0; // To store Content-Length for POST requests

    // Read the client's request line by line
    while (client.connected() && (millis() - clientTimeout < 2000)) { // Timeout after 2 seconds of inactivity
      if (client.available()) {
        clientTimeout = millis(); // Reset timeout as long as data is coming in
        char c = client.read();
        if (c == '\n') {
          // If the current line is blank, we've reached the end of the HTTP headers
          if (currentLine.length() == 0) {
            if (isPost) {
              // Read the POST body based on Content-Length (important for proper parsing)
              for (int i = 0; i < contentLength && client.available(); i++) {
                postBody += (char)client.read();
              }
              Serial.println("Received POST Body: " + postBody);

              // Parse the POST body for message and password parameters
              String messageParam = "";
              String passwordParam = "";
              int messageStart = postBody.indexOf("message=");
              if (messageStart != -1) {
                int messageEnd = postBody.indexOf('&', messageStart);
                if (messageEnd == -1) messageEnd = postBody.length(); // If '&' not found, it's the end
                messageParam = postBody.substring(messageStart + 8, messageEnd);
              }

              int passwordStart = postBody.indexOf("password=");
              if (passwordStart != -1) {
                int passwordEnd = postBody.indexOf('&', passwordStart);
                if (passwordEnd == -1) passwordEnd = postBody.length();
                passwordParam = postBody.substring(passwordStart + 9, passwordEnd);
              }

              // --- URL DECODING FOR MESSAGE ---
              messageParam.replace('+', ' '); // Replace '+' with spaces from URL encoding
              String decodedMessage = "";
              for (int i = 0; i < messageParam.length(); i++) {
                if (messageParam.charAt(i) == '%' && (i + 2) < messageParam.length()) {
                  // Convert hex to character
                  char decodedChar = (char)strtol((messageParam.substring(i + 1, i + 3)).c_str(), NULL, 16);
                  decodedMessage += decodedChar;
                  i += 2; // Skip the two hex characters
                } else {
                  decodedMessage += messageParam.charAt(i);
                }
              }
              
              // --- Password Validation and Message Processing ---
              if (passwordParam != WEB_PASSWORD) {
                webFeedbackMessage = "<p class='feedback' style='color:red;'>Incorrect password. Message not sent.</p>";
                Serial.println("Incorrect password entered.");
              } else if (decodedMessage.length() == 0) {
                webFeedbackMessage = "<p class='feedback' style='color:orange;'>Please enter a message.</p>";
              } else {
                // IMPORTANT: Ensure decodedMessage length doesn't exceed MAX_MESSAGE_CONTENT_LEN - 1
                if (decodedMessage.length() >= MAX_MESSAGE_CONTENT_LEN) {
                    decodedMessage = decodedMessage.substring(0, MAX_MESSAGE_CONTENT_LEN - 1);
                    webFeedbackMessage = "<p class='feedback' style='color:orange;'>Message truncated due to length limit.</p>";
                }
                userMessageBuffer = decodedMessage; // Store message for ESP-NOW sending
                webFeedbackMessage = "<p class='feedback' style='color:green;'>Message queued for sending!</p>" + webFeedbackMessage; // Append any previous feedback
                Serial.println("User message received from web: " + userMessageBuffer);
              }
            } // End if (isPost)

            // --- Send HTTP Response (always send the page back) ---
            client.println(F("HTTP/1.1 200 OK"));
            client.println(F("Content-type:text/html"));
            client.println(F("Connection: close")); // Close connection after response
            client.println(); // Blank line signals end of headers

            client.println(F("<!DOCTYPE html><html><head><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">"));
            client.println(F("<style>"));
            client.println(F("body{font-family:Helvetica, Arial, sans-serif;margin:0;padding:0;background-color:#f8f8f8;color:#333;}"));
            client.println(F("header{background-color:#f0f0f0;padding:10px 0;border-bottom:1px solid #ddd;}"));
            client.println(F("h1, h2, h3 {margin:0;padding:5px 0;color:#333;text-align:center;}"));
            client.println(F("h1{font-size:1.4em;}"));
            client.println(F("h2{font-size:1.2em;}"));
            client.println(F("h3{font-size:1.1em;margin-bottom:10px;}"));
            client.println(F("p{margin:3px 0;font-size:0.9em;text-align:center;}"));
            client.println(F(".info-line{font-size:0.8em;color:#666;margin-bottom:10px;}")); // For IP/MAC info
            client.println(F("pre{background:#eee;padding:10px;border-radius:5px;text-align:left;max-width:90%;margin:15px auto;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word;font-size:0.85em;border:1px solid #ccc;}"));
            
            // Form specific styles
            client.println(F("details{background:#fff;padding:15px;border-radius:8px;box-shadow:0 2px 5px rgba(0,0,0,0.1);max-width:450px;margin:15px auto;border:1px solid #ddd;}"));
            client.println(F("summary{font-size:1.1em;font-weight:bold;cursor:pointer;padding:5px 0;text-align:center;}"));
            client.println(F("form{display:flex;flex-direction:column;align-items:center;margin-top:10px;}"));
            client.println(F("label{font-size:0.9em;margin-bottom:5px;align-self:flex-start;width:80%;}"));
            client.println(F("input[type=text], input[type=password]{width:80%;max-width:350px;padding:8px;margin-bottom:10px;border-radius:4px;border:1px solid #ccc;font-size:0.9em;}"));
            client.println(F("input[type=submit]{background-color:#007bff;color:white;padding:8px 15px;border:none;border-radius:4px;cursor:pointer;font-size:1em;transition:background-color 0.3s ease;}"));
            client.println(F("input[type=submit]:hover{background-color:#0056b3;}"));
            
            // Feedback messages
            client.println(F("p.feedback {font-weight: bold; margin: 10px auto; padding: 8px; border-radius: 5px; border: 1px solid; max-width: 90%; text-align: center; font-size: 0.9em;}"));
            client.println(F("p.feedback[style*='color:green'] { background-color: #e6ffe6; border-color: #00cc00;}"));
            client.println(F("p.feedback[style*='color:red'] { background-color: #ffe6e6; border-color: #cc0000;}"));
            client.println(F("p.feedback[style*='color:orange'] { background-color: #fff8e6; border-color: #ff9900;}"));
            client.println(F("</style></head><body>"));

            client.println(F("<header>"));
            client.println(F("<h1>Protest Information Node</h1>"));
            client.println(F("<p>This node is part of a mesh network. Information may be delayed.</p>"));
            
            // --- Display only the last four HEX characters of the MAC address on the webpage ---
            client.printf("<p class='info-line'><strong>IP:</strong> %s | <strong>MAC:</strong> %s</p>", IP.toString().c_str(), MAC_suffix_str.c_str());
            client.println(F("</header>"));

            // Display feedback message from server processing
            if (webFeedbackMessage.length() > 0) {
              client.println(webFeedbackMessage);
              webFeedbackMessage = ""; // Clear for next request
            }
            
            client.println(F("<h2>Serial Data Log:</h2><pre>"));
            client.print(serialBuffer); // This will naturally show most recent on top
            client.println(F("</pre>"));

            // --- Collapsible Text input form ---
            client.println(F("<details>"));
            client.println(F("<summary>Send Message</summary>")); // Clickable summary
            client.println(F("<h3>Send a New Message:</h3>")); // Adjusted heading size for form
            client.println(F("<form action=\"/\" method=\"POST\">"));
            client.println(F("<label for=\"message_input\">Message:</label>"));
            client.println(F("<input type=\"text\" id=\"message_input\" name=\"message\" placeholder=\"Enter your message here\" required maxlength=\"200\">"));
            client.println(F("<label for=\"password_input\">Password:</label>")); // Added password label
            client.println(F("<input type=\"password\" id=\"password_input\" name=\"password\" placeholder=\"Enter password\" required>")); // Added password input field
            // Removed the MAC input field entirely
            client.println(F("<input type=\"submit\" value=\"Send Message\">"));
            client.println(F("</form>"));
            client.println(F("</details>"));
            // --- End Collapsible Text input form ---

            client.println(F("</body></html>"));
            break; // Exit while loop after sending response
          } else { // Reading HTTP headers
            // Check for GET or POST request method
            if (currentLine.startsWith("GET")) {
              isPost = false;
            } else if (currentLine.startsWith("POST")) {
              isPost = true;
            }
            // Look for Content-Length header for POST requests
            int contentLengthIndex = currentLine.indexOf("Content-Length: ");
            if (contentLengthIndex != -1) {
              contentLength = currentLine.substring(contentLengthIndex + 16).toInt();
            }
            currentLine = ""; // Clear currentLine for the next header
          }
        } else if (c != '\r') {
          currentLine += c; // Build up the current line
        }
      }
    }
    client.stop(); // Close the connection when done or timed out
  }

  // --- Process User Message (if successfully validated from the web interface) ---
  if (userMessageBuffer.length() > 0) {
    esp_now_message_t userEspNowMessage;
    // Clear the struct to ensure all bytes are zero, especially the content buffer
    memset(&userEspNowMessage, 0, sizeof(esp_now_message_t)); 

    userEspNowMessage.messageID = esp_random();
    uint8_t selfMac[6];
    // Convert our own MAC_full_str to bytes
    sscanf(MAC_full_str.c_str(), "%02X:%02X:%02X:%02X:%02X:%02X", 
           (unsigned int*)&selfMac[0], (unsigned int*)&selfMac[1], 
           (unsigned int*)&selfMac[2], (unsigned int*)&selfMac[3], 
           (unsigned int*)&selfMac[4], (unsigned int*)&selfMac[5]);
    memcpy(userEspNowMessage.originalSenderMac, selfMac, 6);
    
    // Copy content from String to char array, ensuring null termination.
    strncpy(userEspNowMessage.content, userMessageBuffer.c_str(), MAX_MESSAGE_CONTENT_LEN);
    userEspNowMessage.content[MAX_MESSAGE_CONTENT_LEN - 1] = '\0'; // Explicitly ensure null termination

    // User-sent messages now indicate they are from "User via Node [MAC suffix]"
    String messageToSendFormatted = String("[") + String(userEspNowMessage.messageID, HEX) + "] User via Node " + MAC_suffix_str + " - " + userMessageBuffer;

    // Add to seen messages cache immediately
    addMessageToSeen(userEspNowMessage.messageID, userEspNowMessage.originalSenderMac);

    // Prepend new messages to serialBuffer (most recent on top) and send via ESP-NOW
    serialBuffer = messageToSendFormatted + "\n" + serialBuffer; // Prepend here
    Serial.println("Broadcasting (User): " + messageToSendFormatted);

    if (serialBuffer.length() > 4000) // Keep buffer manageable
      serialBuffer = serialBuffer.substring(0, 4000); // Truncate from the end

    sendToAllPeers(userEspNowMessage); // Broadcast the message

#if USE_DISPLAY
    if (displayActive) displayLastLines(22);
#endif
    userMessageBuffer = ""; // Clear the buffer after processing
  }
}

// Displays the most recent N lines of the serialBuffer on the TFT display
#if USE_DISPLAY
void displayLastLines(int numLines) {
  tft.fillScreen(TFT_BLACK);
  tft.setCursor(0, 0);
  tft.setTextColor(TFT_CYAN);     tft.println("MAC: " + MAC_full_str); // Full MAC on display
  tft.setTextColor(TFT_GREEN);    tft.println("IP: " + IP.toString());
  tft.setTextColor(TFT_WHITE);    tft.println("----------------------");

  // Since serialBuffer has most recent on top, we just print from the beginning
  int linesPrinted = 0;
  int lineStart = 0;
  while (linesPrinted < numLines && lineStart < serialBuffer.length()) {
    int lineEnd = serialBuffer.indexOf('\n', lineStart);
    if (lineEnd == -1) lineEnd = serialBuffer.length(); // Last line
    String line = serialBuffer.substring(lineStart, lineEnd);
    tft.println(line);
    lineStart = lineEnd + 1;
    linesPrinted++;
  }
}
#endif
